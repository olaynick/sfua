
background.js:
--------------------------------------------------
// background.js

// Параметры поиска (для обычного поиска)
let searchParams = {
    eventType: 0,
    key: '%',
    value: 'обновить данные'
};

// Слушаем загрузку вкладки AppMetrica
chrome.tabs.onUpdated.addListener(async (tabId, changeInfo, tab) => {
    if (changeInfo.status === 'complete' && tab.url?.includes('appmetrica.yandex.ru')) {
        console.log(`[Background] Страница AppMetrica загружена: ${tab.url}`);

        // === ОЧИСТКА СОСТОЯНИЯ POPUP И ПОИСКА ОШИБОК ===
        const popupStateKey = `sfua_popup_state_tab_${tabId}`;
        const errorSearchDoneKey = `sfua_error_search_done_tab_${tabId}`;
        const searchInProgressKey = `sfua_search_in_progress_tab_${tabId}`;

        chrome.storage.local.remove([popupStateKey, errorSearchDoneKey, searchInProgressKey], () => {
            if (chrome.runtime.lastError) {
                console.warn(`[Background] Ошибка очистки состояния:`, chrome.runtime.lastError);
            } else {
                console.log(`[Background] Очищено состояние: ${popupStateKey}, ${errorSearchDoneKey}, ${searchInProgressKey}`);
            }
        });

        // Инжектируем вспомогательные скрипты
        loadHelperScripts(tabId).catch(err => {
            console.warn(`[Background] Не удалось инжектировать хелперы сразу:`, err);
        });
    }
});

// Следим за активацией вкладок (опционально)
chrome.tabs.onActivated.addListener(async (activeInfo) => {
    try {
        const tab = await chrome.tabs.get(activeInfo.tabId);
        if (tab.url?.includes('appmetrica.yandex.ru')) {
            await loadHelperScripts(activeInfo.tabId);
        }
    } catch (e) {
        console.warn('Не удалось обновить вкладку при активации:', e);
    }
});

// Основной обработчик сообщений
chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
    console.log("[Background] Получено сообщение:", request);

    // === Обработка updateId — обновление profileId ===
    if (request.action === "updateId") {
        updateProfileId(sender.tab.id, request.newId);
        sendResponse({ success: true });
        return true;
    }

    // === Сброс флагов проверки параметров (для повторного поиска) ===
    if (request.action === "resetParamCheckFlags") {
        const targetTabId = request.tabId || sender.tab?.id;
        if (!targetTabId) {
            sendResponse({ success: false, error: "Не указан tabId" });
            return true;
        }

        try {
            chrome.scripting.executeScript({
                target: { tabId: targetTabId },
                func: () => {
                    const iframe = document.querySelector('iframe.iframe-integration__iframe');
                    if (!iframe || !iframe.contentDocument) {
                        console.warn('SFUA: iframe не доступен при сбросе флагов');
                        return;
                    }

                    const doc = iframe.contentDocument;
                    doc.querySelectorAll('.check_has_already_been_performed')
                        .forEach(el => el.classList.remove('check_has_already_been_performed'));

                    console.log('SFUA: Сброшены флаги проверки параметров внутри iframe');
                }
            });

            console.log(`[Background] Отправлен сброс флагов проверки параметров в вкладку ${targetTabId}`);
            sendResponse({ success: true });
        } catch (err) {
            console.error(`[Background] Ошибка сброса флагов:`, err);
            sendResponse({ success: false, error: err.message });
        }
        return true;
    }

    // === Завершение поиска — сброс флага ===
    if (request.action === "searchCompleted") {
        const tabId = sender.tab?.id;
        if (tabId) {
            const searchInProgressKey = `sfua_search_in_progress_tab_${tabId}`;
            chrome.storage.local.remove(searchInProgressKey, () => {
                if (chrome.runtime.lastError) {
                    console.warn(`[Background] Ошибка удаления флага поиска:`, chrome.runtime.lastError);
                } else {
                    console.log(`[Background] Сброшен флаг поиска: ${searchInProgressKey}`);
                }
            });
        }
        return true;
    }

    // === Обработка модального окна: показать ===
    if (request.action === "showErrorModal") {
        chrome.tabs.query({ active: true, currentWindow: true }, async (tabs) => {
            const tab = tabs[0];
            if (tab && tab.url.includes('appmetrica.yandex.ru')) {
                try {
                    await chrome.scripting.executeScript({
                        target: { tabId: tab.id },
                        func: (text, id) => {
                            window.sfuaErrorModal?.show?.(text, id);
                        },
                        args: [request.text, request.id]
                    });
                } catch (err) {
                    console.error("[Background] Ошибка показа модального окна:", err);
                }
            }
        });
        return true;
    }

    // === Обработка модального окна: скрыть ===
    if (request.action === "hideErrorModal") {
        chrome.tabs.query({ active: true, currentWindow: true }, async (tabs) => {
            const tab = tabs[0];
            if (tab && tab.url.includes('appmetrica.yandex.ru')) {
                try {
                    await chrome.scripting.executeScript({
                        target: { tabId: tab.id },
                        func: () => {
                            window.sfuaErrorModal?.hide?.();
                        }
                    });
                } catch (err) {
                    console.error("[Background] Ошибка скрытия модального окна:", err);
                }
            }
        });
        return true;
    }

    // === Показать FAQ / инструкцию на странице ===
    if (request.action === "showHowToUse") {
        chrome.tabs.query({
            active: true,
            currentWindow: true,
            url: '*://appmetrica.yandex.ru/*'
        }, async (tabs) => {
            const tab = tabs.find(t => t.url.includes('appmetrica.yandex.ru'));
            if (!tab) {
                console.warn('SFUA: AppMetrica не открыта');
                return;
            }

            try {
                await chrome.scripting.executeScript({
                    target: { tabId: tab.id },
                    files: ['how_to_use.js']
                });
                console.log('✅ how_to_use.js инжектирован в страницу');
            } catch (err) {
                console.error('SFUA: Ошибка инъекции how_to_use.js:', err);
            }
        });
        sendResponse({ success: true });
        return true;
    }

    // Определение целевой вкладки
    let targetTabId;

    if (request.tabId) {
        targetTabId = request.tabId;
    } else if (sender.tab?.id) {
        targetTabId = sender.tab.id;
    } else {
        chrome.tabs.query({ active: true, currentWindow: true }, async (tabs) => {
            const currentTab = tabs[0];
            if (!currentTab || !currentTab.url?.includes('appmetrica.yandex.ru')) {
                sendResponse({ success: false, error: "AppMetrica не открыта" });
                return;
            }
            await handleAction(request, currentTab.id, sendResponse);
        });
        return true;
    }

    // Проверка существования вкладки
    chrome.tabs.get(targetTabId, async (tab) => {
        if (chrome.runtime.lastError || !tab || !tab.url.includes('appmetrica.yandex.ru')) {
            console.error(`[Background] Вкладка ${targetTabId} не существует или не AppMetrica`);
            sendResponse({ success: false, error: "Вкладка AppMetrica закрыта или недоступна" });
            return;
        }

        await handleAction(request, targetTabId, sendResponse);
    });

    return true;
});

// Проверка готовности iframe
async function waitForIframeReady(tabId) {
    for (let i = 0; i < 40; i++) {
        try {
            const result = await chrome.scripting.executeScript({
                target: { tabId: tabId },
                func: () => {
                    const iframe = document.querySelector('iframe.iframe-integration__iframe');
                    return !!iframe && !!iframe.contentDocument?.body;
                }
            });

            if (Array.isArray(result) && result[0]?.result) {
                console.log("[Background] iframe готов");
                return true;
            }
        } catch (e) {
            console.log("[Background] iframe ещё не готов, попытка:", i + 1, e.message || '');
        }
        await new Promise(resolve => setTimeout(resolve, 300));
    }
    console.warn("[Background] iframe не загрузился за отведённое время");
    return false;
}

// Загрузка вспомогательных скриптов
async function loadHelperScripts(tabId) {
    const scripts = [
        'background/userinfo.js',
        'background/updateId.js'
    ];

    for (const file of scripts) {
        try {
            await chrome.scripting.executeScript({
                target: { tabId: tabId },
                files: [file]
            });
            console.log(`[Background] Инжектирован: ${file}`);
        } catch (err) {
            console.error(`[Background] Ошибка инъекции ${file}:`, err);
        }
    }
}

// Обработка действий
async function handleAction(request, targetTabId, sendResponse) {
    try {
        if (request.action === "getSearchParams") {
            sendResponse(searchParams);
            return;
        }

        // === Запуск обычного поиска ===
        if (request.action === "startSearch") {
            searchParams = {
                eventType: request.eventType ?? 0,
                key: request.key ?? '%',
                value: request.value ?? 'обновить данные'
            };
            console.log("[Background] Параметры поиска:", searchParams);

            const ready = await waitForIframeReady(targetTabId);
            if (!ready) {
                throw new Error("iframe не загрузился");
            }

            await injectScript(targetTabId, 'progress.js');
            await injectScript(targetTabId, 'actions/showmoresession.js');
            sendResponse({ success: true });
        }

        // === Запуск поиска ошибок (начало цепочки) ===
        if (request.action === "executeStartErrorSearch") {
            console.log("[Background] Запуск потока поиска ошибок...");

            const ready = await waitForIframeReady(targetTabId);
            if (!ready) {
                throw new Error("iframe не загрузился");
            }

            // ✅ Сначала модальное окно
            await injectScript(targetTabId, 'modal_error.js');

            // ✅ Потом прогресс
            await injectScript(targetTabId, 'progress_error.js');
            await injectScript(targetTabId, 'actions/showmoresession_error.js');
            sendResponse({ success: true });
            return;
        }

        // === Остальные скрипты ===
        const scriptMap = {
            "executeLoadAllEvents": "actions/loadallevents.js",
            "executeClickPlusElement": "actions/clickpluselements.js",
            "executeClickEventElements": "actions/clickeventelements.js",
            "executeLoadAllEventsError": "actions/loadallevents_error.js",
            "executeFoundError": "actions/found_error.js"
        };

        if (scriptMap[request.action]) {
            const ready = await waitForIframeReady(targetTabId);
            if (!ready) {
                sendResponse({ success: false, error: "iframe не готов" });
                return;
            }

            await chrome.scripting.executeScript({
                target: { tabId: targetTabId },
                files: [scriptMap[request.action]]
            });
            sendResponse({ success: true });
        } else {
            console.warn("[Background] Неизвестное действие:", request.action);
            sendResponse({ success: false, error: "Неизвестное действие" });
        }
    } catch (err) {
        console.error("[Background] Ошибка при обработке действия:", err);
        if (!sendResponse.sent) {
            sendResponse({ success: false, error: err.message });
        }
    }
}

// === Цепочка обычного поиска ===
async function startSearchFlow(tabId) {
    console.log("[Background] Запуск потока обычного поиска...");

    const iframeReady = await waitForIframeReady(tabId);
    if (!iframeReady) {
        throw new Error("iframe не загрузился");
    }

    await injectScript(tabId, 'progress.js');
    await injectScript(tabId, 'actions/showmoresession.js');
}

// === Цепочка поиска ошибок ===
async function startErrorSearchFlow(tabId) {
    console.log("[Background] Запуск потока поиска ошибок...");

    const iframeReady = await waitForIframeReady(tabId);
    if (!iframeReady) {
        throw new Error("iframe не загрузился");
    }

    await injectScript(tabId, 'modal_error.js');
    await injectScript(tabId, 'progress_error.js');
    await injectScript(tabId, 'actions/showmoresession_error.js');
}

// === Инжектирование скрипта ===
async function injectScript(tabId, file) {
    try {
        await chrome.scripting.executeScript({
            target: { tabId: tabId },
            files: [file]
        });
        console.log(`[Background] Инжектирован: ${file}`);
    } catch (err) {
        console.error(`[Background] Ошибка инъекции ${file}:`, err);
        throw new Error(`Не удалось загрузить ${file}`);
    }
}

// === Обновление ID ===
function updateProfileId(tabId, newId) {
    chrome.scripting.executeScript({
        target: { tabId: tabId },
        func: (id) => {
            const iframes = document.querySelectorAll('iframe.iframe-integration__iframe');
            iframes.forEach(iframe => {
                try {
                    const src = iframe.src;
                    const newSrc = src.replace(/profileId=\d+/, `profileId=${id}`)
                                    .replace(/deviceId=\d+/, `deviceId=${id}`);
                    iframe.src = newSrc;
                } catch (e) {
                    console.error('Ошибка обновления iframe:', e);
                }
            });
            setTimeout(() => location.reload(), 1000);
        },
        args: [newId]
    });
}


how_to_use.js:
--------------------------------------------------
// how_to_use.js — без анимации высоты, с фиксированной высотой

(function () {
    console.log("SFUA: how_to_use.js — запущен");

    if (document.querySelector('.sfua_howto_modal')) {
        console.log("SFUA: Модалка уже открыта");
        return;
    }

    const cssUrl = chrome.runtime.getURL('how_to_use.css');
    const htmlUrl = chrome.runtime.getURL('how_to_use.html');

    fetch(cssUrl)
        .then(response => {
            if (!response.ok) throw new Error(`CSS: ${response.status} ${response.statusText}`);
            return response.text();
        })
        .then(css => {
            const style = document.createElement('style');
            style.textContent = css;
            document.head.appendChild(style);

            return fetch(htmlUrl);
        })
        .then(response => {
            if (!response.ok) throw new Error(`HTML: ${response.status} ${response.statusText}`);
            return response.text();
        })
        .then(html => {
            const template = document.createElement('div');
            template.innerHTML = html.trim();

            const modal = template.querySelector('.sfua_howto_modal');
            const body = modal.querySelector('.sfua_howto_body');
            const tabs = modal.querySelectorAll('.sfua_howto_tab');
            const panels = modal.querySelectorAll('.sfua_howto_panel');

            document.body.appendChild(modal);

            // === Логика вкладок ===
            function activateTab(tabId) {
                tabs.forEach(t => t.classList.remove('active'));
                panels.forEach(p => p.classList.remove('active'));

                const tab = modal.querySelector(`[data-tab="${tabId}"]`);
                const panel = modal.querySelector(`#${tabId}`);
                if (tab && panel) {
                    tab.classList.add('active');
                    panel.classList.add('active');
                }
            }

            tabs.forEach(tab => {
                tab.addEventListener('click', () => activateTab(tab.dataset.tab));
            });

            // Активируем первую вкладку
            activateTab('basics');

            // === Кнопки закрытия ===
            const closeBtn = modal.querySelector('.sfua_howto_close');
            const okBtn = modal.querySelector('.sfua_howto_ok');

            function closeModal() {
                modal.style.opacity = '0';
                setTimeout(() => modal.remove(), 300);
            }

            closeBtn?.addEventListener('click', closeModal);
            okBtn?.addEventListener('click', closeModal);
            modal.addEventListener('click', (e) => {
                if (e.target === modal) closeModal();
            });

            // === Escape ===
            function handleKeydown(e) {
                if (e.key === 'Escape') {
                    closeModal();
                    document.removeEventListener('keydown', handleKeydown);
                }
            }
            document.addEventListener('keydown', handleKeydown);

            // === Показываем ===
            setTimeout(() => {
                modal.style.opacity = '1';
                modal.querySelector('.sfua_howto_content').style.transform = 'scale(1)';
            }, 10);
        })
        .catch(err => {
            console.error("SFUA: Ошибка загрузки ресурсов:", err);
        });
})();


progress.js:
--------------------------------------------------
// progress.js

(function () {
    console.log("Progress UI: Инициализация (в родительской странице)");

    // === Удаляем старые контейнеры ===
    const existingErrorContainer = document.querySelector('.sfua_error_container');
    if (existingErrorContainer) {
        existingErrorContainer.style.transform = 'scale(0)';
        existingErrorContainer.style.opacity = '0';
        setTimeout(() => existingErrorContainer.remove(), 300);
    }

    const existingContainer = document.querySelector('.sfua_result_container');
    if (existingContainer) {
        existingContainer.style.transform = 'scale(0)';
        existingContainer.style.opacity = '0';
        setTimeout(() => existingContainer.remove(), 300);
    }

    // === Загружаем стили ===
    const style = document.createElement('link');
    style.rel = 'stylesheet';
    style.href = chrome.runtime.getURL('progress.css');
    document.head.appendChild(style);

    // === Контейнер ===
    const targetContainer = document.querySelector('.screen__header');
    if (!targetContainer) {
        console.warn("⚠️ .screen__header не найден");
        return;
    }

    const container = document.createElement('div');
    container.className = 'sfua_result_container';
    container.style.cssText = `
        transform: scale(0);
        opacity: 0;
        transform-origin: top center;
        transition: transform 0.3s ease, opacity 0.3s ease;
    `;

    targetContainer.parentNode.insertBefore(container, targetContainer.nextSibling);

    // === Кнопка "следить" — стрелка вниз ===
    const followBtn = document.createElement('div');
    followBtn.style.cssText = `
        position: absolute;
        top: 8px;
        left: 8px;
        width: 26px;
        height: 26px;
        cursor: pointer;
        opacity: 0.7;
        transition: color 0.2s ease, opacity 0.2s ease;
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 10001;
    `;

    const arrowSvg = `
        <svg xmlns="http://www.w3.org/2000/svg" width="21" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <line x1="12" y1="5" x2="12" y2="19"></line>
            <polyline points="19 12 12 19 5 12"></polyline>
        </svg>
    `;
    followBtn.innerHTML = arrowSvg;

    let isFollowing = false;

    function updateFollowBtn(follow) {
        followBtn.style.color = follow ? '#4299e1' : '#a0aec0';
        followBtn.style.opacity = follow ? '1' : '0.7';
        isFollowing = follow;
        if (follow) {
            container.classList.add('following');
        } else {
            container.classList.remove('following');
        }
    }

    followBtn.addEventListener('click', async (e) => {
        e.stopPropagation();
        e.preventDefault();
        const newFollow = !isFollowing;
        console.log(`[Progress] Follow mode: ${newFollow}`);
        updateFollowBtn(newFollow);
        await chrome.storage.local.set({ sfua_followMode: newFollow });
    });

    container.appendChild(followBtn);

    // === Крестик — справа ===
    const closeBtn = document.createElement('button');
    closeBtn.innerHTML = '&times;';
    closeBtn.style.cssText = `
        position: absolute;
        top: 6px;
        right: 8px;
        width: 26px;
        height: 26px;
        background: none;
        border: none;
        font-size: 26px;
        cursor: not-allowed;
        color: #718096;
        opacity: 0.4;
        z-index: 10001;
    `;
    closeBtn.setAttribute('title', 'Закрыть можно только после завершения поиска');

    closeBtn.addEventListener('click', (e) => {
        if (closeBtn.style.cursor === 'not-allowed') {
            e.stopPropagation();
            e.preventDefault();
        }
    });

    container.appendChild(closeBtn);

    // === Верхняя часть: круги, текст ===
    const header = document.createElement('div');
    header.className = 'progress_header';

    const circlesContainer = document.createElement('div');
    circlesContainer.className = 'progress_circles';

    for (let i = 0; i < 4; i++) {
        const wrapper = document.createElement('div');
        wrapper.className = 'circle_wrapper';
        const circle = document.createElement('div');
        circle.className = 'progress_circle';
        wrapper.appendChild(circle);
        circlesContainer.appendChild(wrapper);
    }

    const operationText = document.createElement('span');
    operationText.className = 'current_operation';
    operationText.textContent = 'Загружаю сессии';

    header.appendChild(circlesContainer);
    header.appendChild(operationText);
    container.appendChild(header);

    // === Результаты ===
    const resultsContainer = document.createElement('div');
    resultsContainer.className = 'results_container';
    container.appendChild(resultsContainer);

    // === Плавное появление ===
    setTimeout(() => {
        container.style.transform = 'scale(1)';
        container.style.opacity = '1';
    }, 100);

    // === Загрузка состояния followMode ===
    chrome.storage.local.get(['sfua_followMode'], (result) => {
        const follow = !!result.sfua_followMode;
        console.log(`[Progress] Загружено состояние followMode: ${follow}`);
        updateFollowBtn(follow);
    });

    // === Логика прокрутки ===
    function handleScroll() {
        const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
        if (isFollowing && scrollTop >= 150) {
            container.classList.add('pinned');
        } else {
            container.classList.remove('pinned');
        }
    }

    window.addEventListener('scroll', handleScroll);
    handleScroll();

    // === SVG иконка глаза (голубой) ===
    const EYE_ICON = `
        <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="#3182ce" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
            <circle cx="12" cy="12" r="3"></circle>
        </svg>
    `;

    // === Глобальный интерфейс ===
    window.sfuaProgress = {
        container,
        circles: container.querySelectorAll('.progress_circle'),
        operationText,
        resultsContainer,

        setStep(step, text) {
            this.circles.forEach((c, i) => {
                c.style.width = '20px';
                c.style.height = '20px';
                c.style.backgroundColor = '#edf2f7';
            });
            for (let i = 0; i < step - 1; i++) {
                this.circles[i].style.backgroundColor = '#4299e1';
            }
            if (step >= 1 && step <= 4) {
                const c = this.circles[step - 1];
                c.style.width = '10px';
                c.style.height = '10px';
                c.style.backgroundColor = '#4299e1';
            }
            if (text) this.operationText.textContent = text;
        },

        startProgress(baseText, total) {
            this.operationText.textContent = baseText;
            const progressText = document.createElement('span');
            progressText.style.cssText = `
                display: inline;
                margin-left: 6px;
                opacity: 0;
                transition: opacity 0.3s ease;
            `;
            this.operationText.appendChild(progressText);

            setTimeout(() => {
                progressText.textContent = `1 из ${total}`;
                progressText.style.opacity = '1';
            }, 300);

            return (current) => {
                if (progressText.parentNode) {
                    progressText.textContent = `${current} из ${total}`;
                }
            };
        },

        updateProgress(updateFn) {
            if (typeof updateFn === 'function') {
                updateFn();
            }
        },

        addResult(result) {
            const link = document.createElement('div');
            link.className = 'sfua_result_item';
            link.style.cssText = `
                padding: 5px 10px;
                background-color: #edf2f7;
                border-radius: 6px;
                font-size: 11px;
                font-weight: 500;
                color: #4a5568;
                cursor: pointer;
                white-space: nowrap;
                opacity: 0;
                transform: translateY(4px);
                display: flex;
                align-items: center;
                gap: 6px;
                transition: all 0.2s ease;
                user-select: none;
            `;

            link.textContent = `${result.shortDateText} ${result.timeText}`;

            // === Иконка "глаз" — изначально скрыта ===
            const eyeIcon = document.createElement('span');
            eyeIcon.className = 'eye-icon';
            eyeIcon.style.cssText = `
                display: inline-flex;
                align-items: center;
                opacity: 0;
                width: 0;
                height: 0;
                overflow: hidden;
                transition: width 0.2s ease, height 0.2s ease, opacity 0.2s ease;
            `;
            eyeIcon.setAttribute('title', 'Просмотрено');
            eyeIcon.innerHTML = EYE_ICON;
            link.appendChild(eyeIcon);

            let isViewed = false;
            let clickTimer = null;

            link.addEventListener('click', (e) => {
                e.stopPropagation();

                // Двойной клик — сбрасываем
                if (e.detail === 2) {
                    if (clickTimer) {
                        clearTimeout(clickTimer);
                        clickTimer = null;
                    }

                    eyeIcon.style.width = '0';
                    eyeIcon.style.height = '0';
                    eyeIcon.style.opacity = '0';
                    isViewed = false;
                    return;
                }

                // Одинарный клик
                if (clickTimer) {
                    clearTimeout(clickTimer);
                    clickTimer = null;
                    return;
                }

                clickTimer = setTimeout(() => {
                    if (!isViewed) {
                        eyeIcon.style.width = '14px';
                        eyeIcon.style.height = '14px';
                        eyeIcon.style.opacity = '0.7';
                        isViewed = true;
                    }

                    // Прокрутка к событию
                    const iframe = document.querySelector('iframe.iframe-integration__iframe');
                    if (!iframe) return;

                    let iframeDoc;
                    try {
                        iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
                    } catch (e) {
                        return;
                    }

                    if (!iframeDoc) return;

                    const target = iframeDoc.getElementById(result.id);
                    if (!target) return;

                    requestAnimationFrame(() => {
                        try {
                            target.scrollIntoView({
                                behavior: 'smooth',
                                block: 'center'
                            });
                        } catch (e) {}
                    });

                    clickTimer = null;
                }, 300);
            });

            this.resultsContainer.appendChild(link);

            setTimeout(() => {
                link.style.opacity = '1';
                link.style.transform = 'translateY(0)';
            }, 10);
        },

        searchComplete() {
            this.circles.forEach(c => {
                c.style.width = '10px';
                c.style.height = '10px';
                c.style.backgroundColor = '#4299e1';
            });

            const resultCount = this.resultsContainer.children.length;
            this.operationText.textContent = resultCount > 0
                ? `Поиск завершён. Найдено совпадений: ${resultCount}`
                : "Поиск завершён. Искомые события не найдены";

            closeBtn.style.cursor = 'pointer';
            closeBtn.style.opacity = '0.7';
            closeBtn.removeAttribute('title');
            closeBtn.title = 'Закрыть';

            closeBtn.addEventListener('click', () => {
                console.log('[Progress] Контейнер закрыт');
                container.style.transform = 'scale(0)';
                container.style.opacity = '0';
                setTimeout(() => container.remove(), 300);
            });

            try {
                chrome.runtime.sendMessage({ action: "searchCompleted" });
            } catch (e) {
                console.warn("SFUA: Не удалось отправить searchCompleted", e);
            }
        }
    };

    window.sfuaProgress.setStep(1, "Загружаю сессии");

    console.log("Progress UI: Готов (в родительской странице)");
})();


progress_error.css:
--------------------------------------------------
/* progress_error.css */

/* === Основной контейнер === */
.sfua_error_container {
    width: 100%;
    background: white;
    border: 1px solid #e2e8f0;
    border-radius: 8px;
    box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
    overflow: hidden;
    z-index: 10000;
    font-family: 'Segoe UI', sans-serif;
    font-size: 12px;
    color: #4a5568;
    position: relative;
    margin: 10px auto 8px;
    box-sizing: border-box;
}

.sfua_error_container.pinned {
    position: fixed;
    top: -40px;
    left: 25%;
    transform: translateX(-50%);
    width: 1200px;
    margin: 0 !important;
    z-index: 10001;
    animation: slideDown 0.3s forwards;
}

@keyframes slideDown {
    from { top: -40px; }
    to { top: 10px; }
}

.sfua_error_container.pinned:not(.following) {
    position: static;
    margin: 10px auto 8px;
}

/* Круги */
.sfua_error_container .circle_wrapper {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 20px;
    height: 20px;
}

.sfua_error_container .progress_circle {
    width: 20px;
    height: 20px;
    background-color: #edf2f7;
    border-radius: 50%;
    transition: all 0.2s ease;
}

/* Заголовок */
.sfua_error_container .progress_header {
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 8px 0;
    width: 100%;
}

.sfua_error_container .progress_circles {
    display: flex;
    gap: 10px;
    justify-content: center;
    margin-bottom: 6px;
    width: 100%;
    max-width: 180px;
}

.sfua_error_container .current_operation {
    text-align: center;
    font-weight: 500;
    font-size: 13px;
}

/* Результаты */
.sfua_error_container .results_container {
    display: flex;
    flex-wrap: wrap;
    gap: 6px;
    padding: 0 12px 8px;
    max-height: 100px;
    overflow-y: auto;
    justify-content: center;
}

/* Кнопки результатов */
.sfua_error_container .results_container .sfua_error_result_item {
    padding: 5px 10px;
    background-color: #f7fafc;
    border-radius: 6px;
    font-size: 11px;
    font-weight: 500;
    color: #4a5568;
    cursor: pointer;
    white-space: nowrap;
    opacity: 0;
    transform: translateY(4px);
    transition: 
        opacity 0.2s ease,
        transform 0.2s ease;
}

/* Появление */
.sfua_error_container .results_container .sfua_error_result_item {
    opacity: 0;
    transform: translateY(4px);
}

/* Обычный hover */
.sfua_error_container .results_container .sfua_error_result_item:hover {
    background-color: rgb(203, 212, 221) !important;
    transform: translateY(0);
    box-shadow: 0 1px 3px rgba(255, 68, 62, 0.15);
    transition: 
        background-color 0.2s ease,
        color 0.2s ease,
        transform 0.1s ease,
        box-shadow 0.2s ease,
        border 0.2s ease;
}

/* hover для крэшей */
.sfua_error_container .results_container .sfua_error_result_item[is-crash]:hover {
    background-color: #feb2b2 !important;
    color: #9b2c2c !important;
    font-weight: 600;
    box-shadow: 0 2px 4px rgba(255, 68, 62, 0.2);
    transform: translateY(-1px);
}

/* Модальное окно */
.sfua_error_tooltip {
    position: fixed;
    top: 400px;
    left: 50%;
    transform: translateX(-50%) scale(0);
    max-width: 700px;
    background: white;
    border: 1px solid #e2e8f0;
    border-radius: 8px;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    padding: 12px 16px;
    font-size: 13px;
    color: #4a5568;
    z-index: 20000;
    white-space: pre-wrap;
    word-break: break-word;
    line-height: 1.4;
    transform-origin: center;
    transition: transform 0.3s ease, opacity 0.3s ease;
    opacity: 0;
    display: flex;
    align-items: flex-start;
    gap: 12px;
}

.sfua_error_tooltip_text {
    flex: 1;
}

.sfua_error_tooltip_buttons {
    display: flex;
    flex-direction: column;
    gap: 8px;
    align-items: center;
}

.sfua_error_tooltip_btn {
    width: 40px;
    height: 40px;
    border-radius: 20%;
    background-color: rgb(237, 242, 247);
    color: rgb(74, 85, 104);
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: background-color 0.2s ease, transform 0.1s ease;
}

.sfua_error_tooltip_btn:hover {
    transform: scale(1.05);
}


modal_error.js:
--------------------------------------------------
// modal_error.js

(function () {
    console.log("🔧 modal_error.js: Инициализация");

    let modal = null;
    let currentId = null;
    let hasScrolledFromModal = false;

    function getContainerBottom() {
        const container = document.querySelector('.sfua_error_container');
        if (!container) return 400;
        const rect = container.getBoundingClientRect();
        return rect.bottom;
    }

    function updateModalPosition() {
        if (!modal) return;
        const left = window.innerWidth * 0.25;
        modal.style.top = `${getContainerBottom() + 30}px`;
        modal.style.left = `${left}px`;
    }

    function createModal() {
        if (modal) return;

        modal = document.createElement('div');
        modal.className = 'sfua_error_modal';
        modal.style.cssText = `
            position: fixed;
            top: 0;
            left: 25%;
            transform: scale(0);
            max-width: 700px;
            min-width: 200px;
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            padding: 16px;
            font-size: 14px;
            color: #4a5568;
            z-index: 2147483647;
            white-space: pre-wrap;
            word-break: break-word;
            line-height: 1.5;
            transform-origin: top;
            transition: 
                transform 0.3s ease,
                top 0.3s ease,
                left 0.3s ease,
                opacity 0.3s ease;
            opacity: 0;
            display: flex;
            align-items: flex-start;
            gap: 16px;
        `;

        const textEl = document.createElement('div');
        textEl.style.flex = '1';
        modal.appendChild(textEl);

        const buttonsContainer = document.createElement('div');
        buttonsContainer.style.cssText = `
            display: flex;
            flex-direction: column;
            gap: 10px;
            align-items: center;
        `;
        modal.appendChild(buttonsContainer);

        // === Кнопка "Скролл к ошибке" ===
        const scrollBtn = document.createElement('div');
        scrollBtn.style.cssText = `
            width: 40px;
            height: 40px;
            border-radius: 20%;
            background-color: rgb(237, 242, 247);
            color: rgb(74, 85, 104);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: background-color 0.2s ease;
        `;
        scrollBtn.innerHTML = `
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <line x1="12" y1="5" x2="12" y2="19"></line>
                <polyline points="19 12 12 19 5 12"></polyline>
            </svg>
        `;
        scrollBtn.addEventListener('click', () => {
            const iframe = document.querySelector('iframe.iframe-integration__iframe');
            if (!iframe) return;

            let iframeDoc;
            try {
                iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
            } catch (e) {
                return;
            }

            if (!iframeDoc) return;

            const target = iframeDoc.getElementById(currentId);
            if (!target) return;

            target.style.transition = 'background-color 0.3s ease';
            target.style.backgroundColor = '#fff4f4';
            setTimeout(() => {
                target.style.backgroundColor = '';
            }, 5000);

            requestAnimationFrame(() => {
                try {
                    target.scrollIntoView({
                        behavior: 'smooth',
                        block: 'center'
                    });
                } catch (e) {}
            });

            hasScrolledFromModal = true;
            // Уведомляем progress, что был скролл
            window.sfuaErrorProgress?.onScrollFromModal?.(currentId);
            hideModal();
        });
        buttonsContainer.appendChild(scrollBtn);

        // === Кнопка "Копировать" ===
        const copyBtn = document.createElement('div');
        copyBtn.style.cssText = `
            width: 40px;
            height: 40px;
            border-radius: 20%;
            background-color: rgb(237, 242, 247);
            color: rgb(74, 85, 104);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: background-color 0.2s ease;
        `;
        copyBtn.innerHTML = `
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
            </svg>
        `;
        copyBtn.addEventListener('click', async () => {
            const text = modal.querySelector('div').textContent;
            try {
                await navigator.clipboard.writeText(text);
                copyBtn.style.backgroundColor = '#48bb78';
                copyBtn.style.color = 'white';
                setTimeout(() => {
                    copyBtn.style.backgroundColor = 'rgb(237, 242, 247)';
                    copyBtn.style.color = 'rgb(74, 85, 104)';
                }, 1000);
            } catch (err) {
                console.error('Не удалось скопировать', err);
            }
        });
        buttonsContainer.appendChild(copyBtn);

        document.body.appendChild(modal);
        updateModalPosition();
    }

    function showModal(text, id) {
        if (currentId === id) return;

        if (modal && currentId !== id) {
            // Анимация вспышки при смене текста
            const textEl = modal.querySelector('div');
            textEl.style.opacity = '0.3';
            setTimeout(() => {
                textEl.textContent = text;
                textEl.style.opacity = '1';
            }, 50);
            currentId = id;
            hasScrolledFromModal = false;
            updateModalPosition();
            return;
        }

        hideModal();
        currentId = id;
        hasScrolledFromModal = false;

        setTimeout(() => {
            createModal();
            const textEl = modal.querySelector('div');
            textEl.textContent = text;
            updateModalPosition();
            modal.style.opacity = '1';
            modal.style.transform = 'scale(1)';
        }, 10);
    }

    function hideModal() {
        currentId = null;
        hasScrolledFromModal = false;

        if (modal) {
            modal.style.transform = 'scale(0)';
            modal.style.opacity = '0';

            setTimeout(() => {
                if (modal) {
                    modal.remove();
                    modal = null;
                }
            }, 300);
        }
    }

    // === Слушатели для обновления позиции ===
    function onScrollOrResize() {
        if (modal) {
            updateModalPosition();
        }
    }

    function setupListeners() {
        window.addEventListener('scroll', onScrollOrResize, { passive: true });
        window.addEventListener('resize', onScrollOrResize, { passive: true });

        const container = document.querySelector('.sfua_error_container');
        if (container) {
            const resizeObserver = new ResizeObserver(onScrollOrResize);
            resizeObserver.observe(container);
        }
    }

    // === Клик вне — закрыть, кроме кнопок прогресса ===
    document.addEventListener('click', (e) => {
        if (!modal) return;

        const progressButton = e.target.closest('.sfua_error_result_item');
        if (progressButton) {
            // Клик по кнопке → обновляем, не закрываем
            const fullText = progressButton.textContent.replace(/👁️.*$/, '').trim();
            const eyeIcon = progressButton.querySelector('.eye-icon');
            const id = eyeIcon?.getAttribute('data-id');
            if (id) {
                showModal(fullText, id);
            }
            return;
        }

        if (!modal.contains(e.target)) {
            hideModal();
        }
    });

    // === Нажатие Esc — закрыть модалку ===
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
            hideModal();
        }
    });

    // === Глобальный интерфейс ===
    window.sfuaErrorModal = {
        showModal,
        hideModal,
        onButtonEnter() {
            if (modal) {
                updateModalPosition();
            }
        },
        onButtonLeave() {
            // не закрываем
        },
        hasScrolled() {
            return hasScrolledFromModal;
        }
    };

    setupListeners();
    console.log("✅ modal_error.js: Готов");
})();


path.py:
--------------------------------------------------
import os
import stat

def get_permissions(path):
    file_stat = os.stat(path)
    permissions = stat.filemode(file_stat.st_mode)
    return permissions

def print_directory_structure(root_dir, level=0, is_last=True):
    items = os.listdir(root_dir)
    items_count = len(items)

    for index, item in enumerate(items):
        item_path = os.path.join(root_dir, item)

        # Пропускаем папку node_modules
        if item == 'node_modules':
            continue
        
        # Определяем, является ли текущий элемент последним в уровне
        is_last_item = index == items_count - 1
        connector = '└─ ' if is_last_item else '├─ '

        permissions = get_permissions(item_path)
        print(' ' * (level * 4) + connector + f'{item} ({permissions})')

        if os.path.isdir(item_path):
            # Рекурсивный вызов для поддиректорий, передаем is_last_item
            print_directory_structure(item_path, level + 1, is_last_item)


root_directory = '/home/olaynick/Рабочий стол/sfua fe'
print_directory_structure(root_directory)


128.png:
--------------------------------------------------
PNG

   
IHDR         >a   	pHYs  .#  .#x?v  
iTXtXML:com.adobe.xmp     <?xpacket begin="﻿" id="W5M0MpCehiHzreSzNTczkc9d"?> <x:xmpmeta xmlns:x="adobe:ns:meta/" x:xmptk="Adobe XMP Core 6.0-c003 116.ddc7bc4, 2021/08/17-13:18:37        "> <rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"> <rdf:Description rdf:about="" xmlns:xmp="http://ns.adobe.com/xap/1.0/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:xmpMM="http://ns.adobe.com/xap/1.0/mm/" xmlns:stEvt="http://ns.adobe.com/xap/1.0/sType/ResourceEvent#" xmlns:stRef="http://ns.adobe.com/xap/1.0/sType/ResourceRef#" xmlns:photoshop="http://ns.adobe.com/photoshop/1.0/" xmlns:tiff="http://ns.adobe.com/tiff/1.0/" xmlns:exif="http://ns.adobe.com/exif/1.0/" xmp:CreatorTool="Adobe Photoshop 21.2 (Windows)" xmp:CreateDate="2025-05-27T20:00:26+04:00" xmp:MetadataDate="2025-05-29T08:47:51+04:00" xmp:ModifyDate="2025-05-29T08:47:51+04:00" dc:format="image/png" xmpMM:InstanceID="xmp.iid:5197223e-f544-dc48-ab82-a8d81efe79f7" xmpMM:DocumentID="adobe:docid:photoshop:264f81c3-0cb1-594d-80c9-c677b4505719" xmpMM:OriginalDocumentID="xmp.did:a90bc5b9-7cea-af49-a9ed-f1346aff474b" photoshop:ColorMode="3" photoshop:ICCProfile="sRGB IEC61966-2.1" tiff:Orientation="1" tiff:XResolution="3000000/10000" tiff:YResolution="3000000/10000" tiff:ResolutionUnit="2" exif:ColorSpace="65535" exif:PixelXDimension="231" exif:PixelYDimension="231"> <xmpMM:History> <rdf:Seq> <rdf:li stEvt:action="created" stEvt:instanceID="xmp.iid:a90bc5b9-7cea-af49-a9ed-f1346aff474b" stEvt:when="2025-05-27T20:00:26+04:00" stEvt:softwareAgent="Adobe Photoshop 21.2 (Windows)"/> <rdf:li stEvt:action="saved" stEvt:instanceID="xmp.iid:ccc09a5f-f29a-3744-a216-64cd058a4f66" stEvt:when="2025-05-29T08:47:26+04:00" stEvt:softwareAgent="Adobe Photoshop 21.2 (Windows)" stEvt:changed="/"/> <rdf:li stEvt:action="saved" stEvt:instanceID="xmp.iid:5584399b-1f72-904e-9b2e-9cf512790cf2" stEvt:when="2025-05-29T08:47:51+04:00" stEvt:softwareAgent="Adobe Photoshop 21.2 (Windows)" stEvt:changed="/"/> <rdf:li stEvt:action="converted" stEvt:parameters="from application/vnd.adobe.photoshop to image/png"/> <rdf:li stEvt:action="derived" stEvt:parameters="converted from application/vnd.adobe.photoshop to image/png"/> <rdf:li stEvt:action="saved" stEvt:instanceID="xmp.iid:5197223e-f544-dc48-ab82-a8d81efe79f7" stEvt:when="2025-05-29T08:47:51+04:00" stEvt:softwareAgent="Adobe Photoshop 21.2 (Windows)" stEvt:changed="/"/> </rdf:Seq> </xmpMM:History> <xmpMM:DerivedFrom stRef:instanceID="xmp.iid:5584399b-1f72-904e-9b2e-9cf512790cf2" stRef:documentID="xmp.did:a90bc5b9-7cea-af49-a9ed-f1346aff474b" stRef:originalDocumentID="xmp.did:a90bc5b9-7cea-af49-a9ed-f1346aff474b"/> </rdf:Description> </rdf:RDF> </x:xmpmeta> <?xpacket end="r"?>㱜  IDATxy\U?-$M:i4IH::tX(l	rDuaPT@1&^I;]NUv[՝NIWwI}ιY_{}.%9u1 .n^'|w$O $108qӷ |M8q
K#IWXz!Rxh!Xe.@6BfВP(Ȉ^w3}
B.4
](;<)}ϗtCQR7+H2h,>iu#@#$}
OE
i&	-Lǐ!+&Iha-&} GPDq
Q
-A"=|y J 4)UrN輿cA٤AN1H	Rn4!
  rI4o0A*5I;I !H@])Z{Z2H#44y}\WgW2xF

_%$N '8&<D A 
!&/s<ϻfB0L՗C	iaeZ p0Ф#/U!CJ$W	''tvVR	Թ}B78Ly
2Ix	?CKj9v(KV䊢#5<Uu2ZúF
t:xYuRb$h"e.w}tZG}?R.RWB(*xBǑA)YmVΕUxË)Fnt]POrBu\sţҕv'[:lBWuuS_ <g`#j
V\cӳm_md
P@"py	?]z!u<)p(p$z+H^^;FovDPȠ`1p|-ֿ5a]54K]u+"
q^  &r5ОA:ؘR'/W
lL:Z\7$0U 0w65h'Won#SG:mXmƾՠEw6"AHnrc"t[j*|>UR`1~J#Α{.sZd/:zd1P)IT?^C*S#	i㕐3AC-W뚊Gjh`YȽQNNE3o$1pjcťAOO
tֺޗa/!Rʋݸ<aW&qJ3EJHJӯXL<Zn9h, AB,F44lC/F%rCȢwIS/v67Qn+nd\/v&A6[	 )
EUGVv~6q@jяԋC HJD^i]kNYǑ_3XiD?j	 mY8_$NغL<Y!`1z|Hxhқy
 w
C7|*}xYn+n-_7ѐ :Ï	܏Zn<D`_sbO$sO $Zf%PL$VT*.;?R#d}i'NʌA̠ 5hˡ-1XtJ
8о'LtSN̗<Jh僌qCGG;`0;WUfV躎ytlT>ʀzCvww388H(,?B!bS?zCt_NLbY
@;^})uflH)	DQۏ%af+	@h`o31\q䯇&[iڊG01\A2[מ()!X
WKf:x<N Ue2CJI8&Df>p+0~YͶJ	NgwDd ri8޽{O|p˳;0q}KZ NŶ@=D߿ ڷWnW~<V!- <hj#+ggk믿0K?::JGG?` Pi¤ K= Z􌌌M(T!KM4{?78+TԁTA <AFΡ25qLs~;X^:	z9!х t~+q^<1MD"1φWb+$cӋxn5COO<H~e$3ҳ	'BZ BL
~79hiiAJQ,)%Pa76~PvX!- #<U9^]]]nahy?`t_305,X]`e%okkcbb %gn߱Bu}PaV<U/	ܐmZ[[,w7=$}O&"ء2lCU0 $x荍
\ջK_lw`޽xW@:dٯaxߕS A{fhHŅVKRcx*^ M4vbX9 <p*i"6#"0vދ~qhmmEu($N㴵"Q>(@eT.rkNeiF29۬yl vh
V-@eT``TjE%6~ -!kbb(/9h4Za ,l11d5Q{:0	9A{{;욂th+s/	}?+T@҂ad@5(,5Zo;z{{#r0hiiqr뚑4 :7&8Ԑq(&0u6tn8b1NVu}5@0\&\:::FD@
طou}ƶ rJ ܬ<NPJI  f6;7֤|5 H67ia̼/ߤ|`O4Ԙ{uݓ. L<xu}$ԬL7		X7x'0u;)P4Wgg'h2Btvv2>>^hSH<8*Quiii9)ҁ6g:)m	]/ xjD#}y澕cH L."+R[s[?"nvHyb_%xjo?\O擝OSJ
 {`,O0])u/7%&
QR2~^\~y#brupqShd?{g(mSu5l
8",S4df!~<d
;*lرs$j"oޘ'0%2C[,Vt:F~t#7}6x 
hV/_5[jtغygb]L	!]׼=UU,C ,JkHDOS8P@CN!bull(Jm=;Cq酒 5k?
Xj׫u-AO3M 6{;f[7mcLSa1
|,Q㹼Qlm1&6sf^:NoyK*6mW6Z1p*5wcM5v:]4Tww!bt|>mbJ&
j׳c̈́0
k$7І/%s	0b`
d'xl&(  <|+^rDrLpR C@`V}4g@hGVW]%ä`0CG{x`4'Z@x0Q J@
wB@]cD"5pfOז  9Dn5MOn=[n
z'y)(P6!|fɲ?]+ Q_c6dE=|<ɑ^Λ9Y@غi+4X7]Į񃥒;Q>XYcK:"~e恦k8+Yx#lpƭ;ّ?8 ~C3μW,Dvs:P{#ߌJHx6d!$4}Zio11G-KI֖at?ڐqI	wn
%'J~iә_,c#Hf[6
gk]+iP>=ME{EwY"Z׼dLxӣ8^$
(%m'Bc[y9fu2	ϼf_Oq	 ٶ&Drzw4݃L$=Ѱ~RAp)';H ))~_q~4g?qDU.u.Pɦn?'~Y3'7z6 PuedP>\m6zT2^"
3n`u⋕۰7^^"
zf#`|)w/Ri'R҆!Q(u}aweWw?jpi!4=_ՐLB_@c[z&O4}^w"P>;!RXr
<\PFt*(͌dLkRhK`{6M5_N?z;*Z%_L_pz2L  gܽ,LLwj]_-hJ&&=(͚L3E@3Cn7rZB94hDRY7Wfs	q_B%JH#+qgsUӍ`*Y>i`zǹR3 ʹ>^^a~|Š/ ;wù'3Ne@,{/BrOVFﭺޥ,u}G
\:g&uk*y'
aEԝ5oΟcjZY	 Wv_g+gn`Z=Ru絨7WY8O/YοuE;gt<DP\Κϐٔ=QuB۾|2S܄Y#/)偣zԽ*~.FstS1Խ|8'eN`_8#Vf\<uJ!I]{\ [=[w:)_V7PW91cA?b{1
L?	5v>ԵnU S*p~ 0zFd--3B]٨k-"4E=wQ3u-QVTr tBkQs
/5sqkQr<@7ל/	\ gEUH(̒bL(!\dS/**Lr %U r曁@5ˁ,9z^	gR8aNe`%P";Ud0S_DPv ,9qe*t;    IENDB`


progress_error.js:
--------------------------------------------------
// progress_error.js

(function () {
    console.log("Progress Error: Инициализация");

    // === Удаляем старые контейнеры ===
    const existingResultContainer = document.querySelector('.sfua_result_container');
    if (existingResultContainer) {
        existingResultContainer.style.transform = 'scale(0)';
        existingResultContainer.style.opacity = '0';
        setTimeout(() => existingResultContainer.remove(), 300);
    }

    const existingContainer = document.querySelector('.sfua_error_container');
    if (existingContainer) {
        existingContainer.style.transform = 'scale(0)';
        existingContainer.style.opacity = '0';
        setTimeout(() => existingContainer.remove(), 300);
    }

    // === Загружаем стили ===
    const linkStyle = document.createElement('link');
    linkStyle.rel = 'stylesheet';
    linkStyle.href = chrome.runtime.getURL('progress_error.css');
    document.head.appendChild(linkStyle);

    const targetContainer = document.querySelector('.screen__header');
    if (!targetContainer) {
        console.warn("⚠️ .screen__header не найден");
        return;
    }

    const container = document.createElement('div');
    container.className = 'sfua_error_container';
    container.style.cssText = `
        transform: scale(0);
        opacity: 0;
        transform-origin: top center;
        transition: transform 0.3s ease, opacity 0.3s ease;
    `;

    targetContainer.parentNode.insertBefore(container, targetContainer.nextSibling);

    // === Кнопка "следить" — стрелка вниз ===
    const followBtn = document.createElement('div');
    followBtn.style.cssText = `
        position: absolute;
        top: 8px;
        left: 8px;
        width: 26px;
        height: 26px;
        cursor: pointer;
        opacity: 0.7;
        transition: color 0.2s ease, opacity 0.2s ease;
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 10001;
    `;

    const arrowSvg = `
        <svg xmlns="http://www.w3.org/2000/svg" width="21" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <line x1="12" y1="5" x2="12" y2="19"></line>
            <polyline points="19 12 12 19 5 12"></polyline>
        </svg>
    `;
    followBtn.innerHTML = arrowSvg;

    let isFollowing = false;

    function updateFollowBtn(follow) {
        followBtn.style.color = follow ? '#AB4E52' : '#a0aec0';
        followBtn.style.opacity = follow ? '1' : '0.7';
        isFollowing = follow;
        if (follow) {
            container.classList.add('following');
        } else {
            container.classList.remove('following');
        }
    }

    followBtn.addEventListener('click', async (e) => {
        e.stopPropagation();
        e.preventDefault();
        const newFollow = !isFollowing;
        console.log(`[Progress Error] Follow mode: ${newFollow}`);
        updateFollowBtn(newFollow);
        await chrome.storage.local.set({ sfua_error_followMode: newFollow });
    });

    container.appendChild(followBtn);

    // === Крестик — справа ===
    const closeBtn = document.createElement('button');
    closeBtn.innerHTML = '&times;';
    closeBtn.style.cssText = `
        position: absolute;
        top: 6px;
        right: 8px;
        width: 26px;
        height: 26px;
        background: none;
        border: none;
        font-size: 26px;
        cursor: not-allowed;
        color: #718096;
        opacity: 0.4;
        z-index: 10001;
    `;
    closeBtn.setAttribute('title', 'Закрыть можно только после завершения поиска');

    closeBtn.addEventListener('click', (e) => {
        if (closeBtn.style.cursor === 'not-allowed') {
            e.stopPropagation();
            e.preventDefault();
        }
    });

    container.appendChild(closeBtn);

    // === Верхняя часть: круги, текст ===
    const header = document.createElement('div');
    header.className = 'progress_header';

    const circlesContainer = document.createElement('div');
    circlesContainer.className = 'progress_circles';

    for (let i = 0; i < 3; i++) {
        const wrapper = document.createElement('div');
        wrapper.className = 'circle_wrapper';
        const circle = document.createElement('div');
        circle.className = 'progress_circle';
        wrapper.appendChild(circle);
        circlesContainer.appendChild(wrapper);
    }

    const operationText = document.createElement('span');
    operationText.className = 'current_operation';
    operationText.textContent = 'Загружаю сессии';

    header.appendChild(circlesContainer);
    header.appendChild(operationText);
    container.appendChild(header);

    // === Результаты ===
    const resultsContainer = document.createElement('div');
    resultsContainer.className = 'results_container';
    container.appendChild(resultsContainer);

    // === Плавное появление ===
    setTimeout(() => {
        container.style.transform = 'scale(1)';
        container.style.opacity = '1';
    }, 100);

    // === Загрузка состояния followMode ===
    chrome.storage.local.get(['sfua_error_followMode'], (result) => {
        const follow = !!result.sfua_error_followMode;
        console.log(`[Progress Error] Загружено состояние followMode: ${follow}`);
        updateFollowBtn(follow);
    });

    // === Логика прокрутки ===
    function handleScroll() {
        const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
        if (isFollowing && scrollTop >= 150) {
            container.classList.add('pinned');
        } else {
            container.classList.remove('pinned');
        }
    }

    window.addEventListener('scroll', handleScroll);
    handleScroll();

    // === Функция для перезагрузки modal_error.js ===
    function injectScriptAgain() {
        return new Promise((resolve) => {
            const script = document.createElement('script');
            script.src = chrome.runtime.getURL('modal_error.js');
            script.onload = () => {
                console.log('✅ modal_error.js перезагружен');
                resolve();
            };
            script.onerror = (err) => {
                console.error('❌ Ошибка загрузки modal_error.js', err);
                resolve();
            };
            document.head.appendChild(script);
        });
    }

    // === SVG иконки глаз ===
    const EYE_ICON_GRAY = `
        <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
            <circle cx="12" cy="12" r="3"></circle>
        </svg>
    `;

    const EYE_ICON_BLUE = `
        <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="#3182ce" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
            <circle cx="12" cy="12" r="3"></circle>
        </svg>
    `;

    const EYE_ICON_RED = `
        <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="#AB4E52" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
            <circle cx="12" cy="12" r="3"></circle>
        </svg>
    `;

    // === Глобальный интерфейс ===
    window.sfuaErrorProgress = {
        container,
        circles: container.querySelectorAll('.progress_circle'),
        text: operationText,
        resultsContainer,

        setStep(step, text) {
            this.circles.forEach((c, i) => {
                c.style.width = '20px';
                c.style.height = '20px';
                c.style.backgroundColor = '#edf2f7';
            });
            for (let i = 0; i < step - 1; i++) {
                this.circles[i].style.backgroundColor = '#AB4E52';
            }
            if (step >= 1 && step <= 3) {
                const c = this.circles[step - 1];
                c.style.width = '10px';
                c.style.height = '10px';
                c.style.backgroundColor = '#AB4E52';
            }
            if (text) this.text.textContent = text;
        },

        // Вызывается из modal_error.js при скролле
        onScrollFromModal(id) {
            const buttons = this.resultsContainer.querySelectorAll('.sfua_error_result_item');
            for (const btn of buttons) {
                const eyeIcon = btn.querySelector('.eye-icon');
                if (eyeIcon && eyeIcon.getAttribute('data-id') === id) {
                    eyeIcon.innerHTML = EYE_ICON_BLUE;
                    break;
                }
            }
        },

addResult(result) {
    const link = document.createElement('div');
    link.className = 'sfua_error_result_item';
    link.style.cssText = `
        padding: 5px 10px;
        background-color: #f7fafc;
        border-radius: 6px;
        font-size: 11px;
        font-weight: 500;
        color: #4a5568;
        cursor: pointer;
        white-space: nowrap;
        opacity: 0;
        transform: translateY(4px);
        display: flex;
        align-items: center;
        gap: 6px;
        transition: all 0.2s ease;
        user-select: none;
    `;

    link.textContent = result.shortText;

    if (result.isCrash) {
        link.style.color = '#AB4E52';
        link.style.fontWeight = '600';
        link.setAttribute('is-crash', 'true');
    }

    // === Иконка "глаз" ===
    const eyeIcon = document.createElement('span');
    eyeIcon.className = 'eye-icon';
    eyeIcon.style.cssText = `
        display: inline-flex;
        align-items: center;
        opacity: 0;
        width: 0;
        height: 0;
        overflow: hidden;
        transition: width 0.2s ease, height 0.2s ease, opacity 0.2s ease;
    `;
    eyeIcon.setAttribute('title', 'Просмотрено');
    eyeIcon.innerHTML = EYE_ICON_GRAY;
    eyeIcon.setAttribute('data-id', result.id);
    link.appendChild(eyeIcon);

    let clickTimer = null;
    let isViewed = false;

    link.addEventListener('click', (e) => {
        e.stopPropagation();

        // ❌ Если это двойной клик — сбрасываем и выходим
        if (e.detail === 2) {
            if (clickTimer) {
                clearTimeout(clickTimer);
                clickTimer = null;
            }

            // Сбрасываем состояние
            eyeIcon.style.width = '0';
            eyeIcon.style.height = '0';
            eyeIcon.style.opacity = '0';
            eyeIcon.innerHTML = '';
            isViewed = false;

            return; // Не запускаем одинарный клик
        }

        // ✅ Одинарный клик — запускаем с задержкой
        if (!clickTimer) {
            clickTimer = setTimeout(() => {
                // Только если не было двойного клика
                if (!isViewed) {
                    eyeIcon.style.width = '14px';
                    eyeIcon.style.height = '14px';
                    eyeIcon.style.opacity = '0.7';
                    isViewed = true;
                }

                if (result.isCrash) {
                    // Прокрутка к крэшу
                    const iframe = document.querySelector('iframe.iframe-integration__iframe');
                    if (!iframe) return;

                    let iframeDoc;
                    try {
                        iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
                    } catch (e) {
                        return;
                    }

                    if (!iframeDoc) return;

                    const target = iframeDoc.getElementById(result.id);
                    if (!target) return;

                    target.style.transition = 'background-color 0.3s ease';
                    target.style.backgroundColor = '#fff4f4';
                    setTimeout(() => {
                        target.style.backgroundColor = '';
                    }, 5000);

                    requestAnimationFrame(() => {
                        try {
                            target.scrollIntoView({
                                behavior: 'smooth',
                                block: 'center'
                            });
                        } catch (e) {}
                    });

                    eyeIcon.innerHTML = EYE_ICON_RED;
                } else {
                    // Открываем модалку
                    window.sfuaErrorModal.showModal(result.fullText, result.id);
                    eyeIcon.innerHTML = EYE_ICON_GRAY;
                }

                clickTimer = null;
            }, 300);
        }
    });

    this.resultsContainer.appendChild(link);

    setTimeout(() => {
        link.style.opacity = '1';
        link.style.transform = 'translateY(0)';
    }, 10);
},

        searchComplete(total = 0, crashCount = 0) {
            this.circles.forEach(c => {
                c.style.width = '10px';
                c.style.height = '10px';
                c.style.backgroundColor = '#AB4E52';
            });

            const results = this.resultsContainer.children.length;
            if (results === 0) {
                this.text.textContent = "Поиск завершён. Ошибок не найдено";
            } else {
                this.text.textContent = '';
                this.text.appendChild(document.createTextNode(`Поиск завершён. Найдено ошибок: ${results}`));

                if (crashCount > 0) {
                    this.text.appendChild(document.createTextNode(' из них '));

                    const crashSpan = document.createElement('span');
                    crashSpan.textContent = crashCount;
                    crashSpan.style.color = '#AB4E52';
                    crashSpan.style.fontWeight = '600';

                    this.text.appendChild(crashSpan);
                    this.text.appendChild(document.createTextNode(' Crash'));
                }
            }

            // === Разблокируем крестик ===
            closeBtn.style.cursor = 'pointer';
            closeBtn.style.opacity = '0.7';
            closeBtn.removeAttribute('title');
            closeBtn.title = 'Закрыть';

            closeBtn.onclick = null;
            closeBtn.addEventListener('click', () => {
                console.log('[Progress Error] Контейнер закрыт');
                container.style.transform = 'scale(0)';
                container.style.opacity = '0';
                setTimeout(() => container.remove(), 300);
            });

            try {
                chrome.runtime.sendMessage({ action: "searchCompleted" });
            } catch (e) {
                console.warn("SFUA: Не удалось отправить searchCompleted", e);
            }
        }
    };

    window.sfuaErrorProgress.setStep(1, "Загружаю сессии");

    // Инжектируем modal_error.js при старте
    injectScriptAgain().catch(err => console.error('Ошибка первой загрузки modal_error.js', err));
})();


styles.css:
--------------------------------------------------
/* ===== Базовые стили ===== */
body {
    width: 360px;
    min-width: 340px;
    max-width: 340px;
    padding: 15px;
    margin: 0;
    font-family: 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
    font-size: 13px;
    color: #2d3748;
    background-color: #f7fafc;
    box-sizing: border-box;
  }
  
  * {
    box-sizing: border-box;
  }
  
  /* ===== Основной контейнер ===== */
  .sfua_container {
    display: flex;
    flex-direction: column;
    gap: 12px;
    width: 100%;
  }
  
  /* ===== Секции ===== */
  .section {
    background: white;
    border-radius: 8px;
    padding: 12px 14px;
    box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
    border: 1px solid #e2e8f0;
  }
  
  .section h3 {
    margin: 0 0 8px 0;
    font-size: 13px;
    font-weight: 600;
    color: #4a5568;
  }
  
  
  /* ===== Типы событий ===== */
  .event_types {
    display: flex;
    flex-wrap: wrap;
    gap: 6px;
    margin-top: 6px;
  }
  
  .event_type {
    padding: 5px 10px;
    background-color: #edf2f7;
    border-radius: 6px;
    font-size: 11px;
    font-weight: 500;
    color: #4a5568;
    cursor: pointer;
    transition: all 0.15s ease;
    user-select: none;
    white-space: nowrap;
  }
  
  .event_type:hover {
    background-color: #e2e8f0;
  }
  
  .event_type.active {
    background-color: #4299e1;
    color: white;
  }
  
  /* ===== Параметры поиска ===== */
  .params_row {
    display: flex;
    align-items: center;
    gap: 8px;
    width: 100%;
  }
  
  .param_key, .param_value {
    flex: 1;
    padding: 7px 10px;
    border: 1px solid #e2e8f0;
    border-radius: 6px;
    font-size: 12px;
    color: #2d3748;
    transition: all 0.2s ease;
    width: 50px;
  }
  
  .param_key:focus, .param_value:focus {
    outline: none;
    border-color: #4299e1;
    box-shadow: 0 0 0 3px rgba(66, 153, 225, 0.2);
  }
  
  .equals {
    color: #718096;
    font-size: 14px;
    font-weight: 500;
    user-select: none;
  }
  
  /* ===== Кнопка поиска ===== */
  .search_button {
    width: 100%;
    padding: 10px;
    background-color: #4299e1;
    color: white;
    border: none;
    border-radius: 6px;
    font-size: 14px;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s ease;
    margin-top: 4px;
    text-align: center;
  }
  
  .search_button:hover {
    background-color: #3182ce;
  }
  
  .search_button:active {
    background-color: #2b6cb0;
  }
  
  .search_button:focus {
    outline: none;
    box-shadow: 0 0 0 3px rgba(66, 153, 225, 0.3);
  }
  
  /* ===== Визуальная обратная связь ===== */
  .success_border {
    border-color: #48bb78 !important;
    box-shadow: 0 0 0 3px rgba(72, 187, 120, 0.2) !important;
  }
  
  .error_border {
    border-color: #f56565 !important;
    box-shadow: 0 0 0 3px rgba(245, 101, 101, 0.2) !important;
  }
  
  /* ===== Анимации ===== */
  @keyframes fadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
  }
  
  .sfua_container {
    animation: fadeIn 0.2s ease-out;
  }
  
  /* ===== Кастомные скроллбары ===== */
  ::-webkit-scrollbar {
    width: 6px;
    height: 6px;
  }
  
  ::-webkit-scrollbar-track {
    background: #f1f1f1;
    border-radius: 3px;
  }
  
  ::-webkit-scrollbar-thumb {
    background: #cbd5e0;
    border-radius: 3px;
  }
  
  ::-webkit-scrollbar-thumb:hover {
    background: #a0aec0;
  }
  
  /* ===== Адаптация для разных размеров ===== */
  @media (max-width: 400px) {
    body {
      width: 320px;
      padding: 12px;
    }
    
    .section {
      padding: 10px 12px;
    }
    
    .event_type {
      padding: 4px 8px;
      font-size: 10px;
    }
  }
  
  /* ===== Скрытие стрелок у числового ввода ===== */
  input[type="number"]::-webkit-outer-spin-button,
  input[type="number"]::-webkit-inner-spin-button {
    -webkit-appearance: none;
    margin: 0;
  }
  
/* ===== Кнопки: строка и размеры ===== */
.buttons_row {
  display: flex;
  gap: 10px;
  width: 100%;
  margin-top: 4px;
}

/* ===== Общие стили кнопок ===== */
.buttons_row button {
  height: 40px;
  border: none;
  border-radius: 6px;
  font-size: 14px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s ease;
  display: flex;
  align-items: center;
  justify-content: center;
  text-align: center;
  box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
  padding: 0;
  margin: 0;
  line-height: 1;
}

/* ===== Кнопка "Начать поиск" — 70% ===== */
.search_button {
  width: 70%;
  background-color: #4299e1;
  color: white;
}

.search_button:hover {
  background-color: #3182ce;
}

.search_button:active {
  background-color: #2b6cb0;
}

.search_button:focus {
  outline: none;
  box-shadow: 0 0 0 3px rgba(66, 153, 225, 0.3);
}

/* ===== Кнопка "Ошибка" — 30% ===== */
.error_search_button {
  width: 30%;
  background-color: #AB4E52;
  color: white;
  gap: 6px;
  padding: 0 8px;
  box-sizing: border-box;
}

.error_search_button .error_icon {
  display: inline-block;
  width: 16px;
  height: 16px;
  background: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='white' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Ccircle cx='12' cy='12' r='10'%3E%3C/circle%3E%3Cline x1='12' y1='8' x2='12' y2='12'%3E%3C/line%3E%3Cline x1='12' y1='16' x2='12.01' y2='16'%3E%3C/line%3E%3C/svg%3E") no-repeat center;
  background-size: 16px;
  flex-shrink: 0;
}

.error_search_button .error_text {
  font-size: 12px;
  font-weight: 500;
  line-height: 1;
}

.error_search_button:hover {
  background-color: #9a3d41;
}

.error_search_button:active {
  background-color: #8a3438;
}

.error_search_button:focus {
  outline: none;
  box-shadow: 0 0 0 3px rgba(171, 78, 82, 0.3);
}

/* ===== Стили для disabled-состояния ===== */
.search_button:disabled {
  opacity: 0.7;
  cursor: not-allowed;
  background-color: #718096;
}

/* ===== Кнопка FAQ ===== */
.faq_row {
  margin-top: 8px;
}

.faq_button {
  width: 100%;
  padding: 10px;
  background-color: #f7fafc;
  color: #4a5568;
  border: 1px solid #e2e8f0;
  border-radius: 6px;
  font-size: 13px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s ease;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 6px;
}

.faq_button:hover {
  background-color: #edf2f7;
  border-color: #cbd5e0;
}

.faq_button:active {
  background-color: #e2e8f0;
}

.faq_button:focus {
  outline: none;
  box-shadow: 0 0 0 3px rgba(136, 187, 215, 0.2);
}


how_to_use.html:
--------------------------------------------------
<!-- how_to_use.html -->
<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Руководство по SFUA</title>
    <link rel="stylesheet" href="how_to_use.css" />
</head>
<body>
    <div class="sfua_howto_modal">
        <div class="sfua_howto_content">
            <!-- Заголовок -->
            <div class="sfua_howto_header">
                <span>Руководство по SFUA</span>
                <button class="sfua_howto_close">&times;</button>
            </div>

            <!-- Вкладки -->
            <div class="sfua_howto_tabs">
                <button data-tab="basics" class="sfua_howto_tab active">Основы</button>
                <button data-tab="search" class="sfua_howto_tab">Поиск событий</button>
                <button data-tab="errors" class="sfua_howto_tab">Поиск ошибок</button>
                <button data-tab="progress" class="sfua_howto_tab">Прогресс-бары</button>
                <button data-tab="showcurrent" class="sfua_howto_tab">Развернуть события</button>
                <button data-tab="update" class="sfua_howto_tab">Обновление ID</button>
                <button data-tab="timezone" class="sfua_howto_tab">Время пользователя</button>
            </div>

            <!-- Контент -->
            <div class="sfua_howto_body">
                <!-- Основы -->
                <div id="basics" class="sfua_howto_panel active">
                    <h3>Что такое SFUA?</h3>
                    <p>SFUA (Search For Users Actions) — расширение для анализа пользовательских сессий в Яндекс AppMetrica.</p>
                    <p>Оно автоматизирует рутинные задачи:</p>
                    <ul>
                        <li>Поиск событий по ключу и значению</li>
                        <li>Поиск ошибок и крэшей (красных событий)</li>
                        <li>Автоматическое раскрытие событий в рамках одной сессии</li>
                    </ul>
                </div>

                <!-- Поиск событий -->
                <div id="search" class="sfua_howto_panel">
                    <h3>Поиск событий</h3>
                    <p>Находит события, содержащие указанные параметры.</p>

                    <h4>Как использовать:</h4>
                    <ol>
                        <li>Выберите тип события (например, <code>tap</code>)</li>
                        <li>Введите ключ и/или значение (например, <code>локальная отработка биометрии = успех</code>)</li>
                        <li>Нажмите <strong>«Начать поиск»</strong></li>
                    </ol>

                    <h4>Особенности:</h4>
                    <ul>
                        <li>Поддержка маски <code>%</code>: <code>%биометрия%</code> найдёт все вхождения</li>
                        <li>Можно искать только по ключу или только по значению</li>
                        <li>Горячая клавиша начала поиска: <code>Ctrl+Enter</code></li>
                    </ul>

                    <h4>Результаты поиска:</h4>
                    <ul>
                        <li>Каждая найденная сессия добавляется в виде кнопки</li>
                        <li>При <strong>клике</strong> на кнопку — появляется <strong>голубой глаз</strong> и происходит прокрутка к событию</li>
                        <li>При <strong>двойном клике</strong> — отметка "просмотрено" сбрасывается, глаз исчезает</li>
                    </ul>
                </div>

                <!-- Поиск ошибок -->
                <div id="errors" class="sfua_howto_panel">
                    <h3>Поиск ошибок</h3>
                    <p>Находит все красные события (ошибки и крэши) в сессиях в указанном интервале дат.</p>

                    <h4>Как использовать:</h4>
                    <ol>
                        <li>Нажмите кнопку <strong>«Ошибки»</strong></li>
                        <li>Дождитесь завершения поиска</li>
                        <li>Кликните по кнопке результата — откроется модалка с описанием ошибки</li>
                    </ol>

                    <h4>Поведение кнопок:</h4>
                    <ul>
                        <li><strong>Обычная ошибка</strong>: клик — открытие модалки</li>
                        <li><strong>Крэш</strong>: клик — прокрутка к событию</li>
                        <li>При клике появляется <strong>иконка глаза</strong></li>
                        <li>При наведении на глаз — подсказка <em>«Просмотрено»</em></li>
                        <li>При двойном клике — отметка сбрасывается</li>
                        <li>Текст внутри кнопки нельзя выделить</li>
                    </ul>

                    <h4>Функции модального окна:</h4>
                    <ul>
                        <li><strong>Скролл к событию</strong> — клик по стрелке вниз</li>
                        <li><strong>Копировать текст</strong> — клик по иконке копирования</li>
                        <li>Модалка закрывается:
                            <ul>
                                <li>При клике <strong>вне окна</strong></li>
                                <li>При нажатии <strong>Esc</strong></li>
                            </ul>
                        </li>
                        <li>При клике по другой кнопке — содержимое модалки обновляется без закрытия</li>
                        <li>При прокрутке из модалки — глаз становится <strong>голубым</strong></li>
                    </ul>

                    <h4>Особенности:</h4>
                    <ul>
                        <li><strong>Крэши</strong> выделены жирным красным цветом</li>
                        <li>Иконка глаза появляется только после клика</li>
                    </ul>
                </div>

                <!-- Прогресс-бары -->
                <div id="progress" class="sfua_howto_panel">
                    <h3>Прогресс-бары</h3>
                    <p>Появляются при выполнении поиска. Есть два типа:</p>

                    <h4>1. Прогресс поиска событий</h4>
                    <ul>
                        <li>Появляется при нажатии <strong>«Начать поиск»</strong></li>
                        <li>Четыре круга: загрузка сессий → загрузка событий → раскрытие → клик+поиск</li>
                        <li>Показывает прогресс: <code>Кликаю по событиям и осуществляю поиск: N из 231</code></li>
                        <li>Кнопка со стрелкой — включает режим <strong>«следить»</strong> (закрепление при прокрутке)</li>
                        <li>Крестик недоступен до завершения поиска</li>
                    </ul>

                    <h4>2. Прогресс поиска ошибок</h4>
                    <ul>
                        <li>Появляется при нажатии <strong>«Ошибки»</strong></li>
                        <li>Три круга: загрузка сессий → загрузка событий → поиск</li>
                        <li>Показывает прогресс: <code>Загружаю события: N из X</code></li>
                        <li>Кнопка со стрелкой — включает режим <strong>«следить»</strong> (закрепление при прокрутке)</li>
                        <li>Крестик недоступен до завершения поиска</li>
                    </ul>

                    <h4>Режим «следить»:</h4>
                    <ul>
                        <li>При включении — панель закрепляется при прокрутке страницы</li>
                        <li>Состояние сохраняется между сессиями</li>
                        <li>Повторный клик — отключает режим</li>
                    </ul>

                    <h4>Финальный текст:</h4>
                    <ul>
                        <li><strong>Если совпадений нет</strong>: <code>Поиск завершён. Искомые события не найдены</code></li>
                        <li><strong>Если есть</strong>: <code>Поиск завершён. Найдено совпадений: N</code></li>
                        <li><strong>Для ошибок</strong>: <code>Поиск завершён. Найдено ошибок: N из них X Crash</code> (где <code>X</code> — красное число, если X > 0)</li>
                    </ul>
                </div>

                <!-- Развернуть события -->
                <div id="showcurrent" class="sfua_howto_panel">
                    <h3>Кнопка «Развернуть события»</h3>
                    <p>Автоматически раскрывает скрытые события в сессии: <strong>«+N»</strong>, <strong>«Все N событий»</strong> и основные типы событий.</p>

                    <h4>Как работает:</h4>
                    <ol>
                        <li>Появляется слева от даты каждой сессии</li>
                        <li>При нажатии кликает по всем элементам, которые скрывают события</li>
                        <li>Раскрывает полный поток событий для анализа</li>
                    </ol>

                    <h4>Элементы, по которым кликает:</h4>
                    <ul>
                        <li><strong>«+N»</strong> — раскрывает скрытые события</li>
                        <li><strong>«Все N событий»</strong> — загружает все события в сессии</li>
                        <li><strong>Типы событий</strong>: <code>tap</code>, <code>deeplink</code>, <code>error</code>, <code>tech</code>, <code>authorization</code> и другие из списка</li>
                    </ul>

                    <h4>Защита от дублей:</h4>
                    <ul>
                        <li>Перед кликом проверяет, есть ли у элемента класс <code>span_checked</code></li>
                        <li>Если класс есть — клик пропускается</li>
                        <li>После клика класс <code>span_checked</code> добавляется автоматически</li>
                    </ul>

                    <h4>Состояния кнопки:</h4>
                    <ul>
                        <li><strong>«Развернуть события сессии»</strong> — начальное состояние</li>
                        <li><strong style="color: #555;">«Загрузка...»</strong> — идёт обработка (клик по элементам)</li>
                        <li><strong style="color: #0a0;">«События загружены»</strong> — всё раскрыто</li>
                    </ul>

                    <h4>Особенности:</h4>
                    <ul>
                        <li>Работает в реальном времени — кнопка появляется при загрузке сессии</li>
                        <li>Поддерживает динамическую подгрузку (через <code>MutationObserver</code>)</li>
                        <li>Не мешает другим функциям расширения</li>
                    </ul>
                </div>

                <!-- Обновление ID -->
                <div id="update" class="sfua_howto_panel">
                    <h3>Обновление ID профиля</h3>
                    <p>Позволяет быстро сменить профиль без ручной подмены в адресной строке</p>

                    <h4>Как использовать:</h4>
                    <ol>
                        <li>Скопируйте ID профиля (не менее 15 символов)</li>
                        <li>Вставьте в поле ввода в AppMetrica</li>
                        <li>Нажмите Enter или кнопку «Обновить»</li>
                    </ol>

                    <h4>Валидация:</h4>
                    <ul>
                        <li>Минимальная длина ID — <strong>15 символов</strong></li>
                        <li>ID должен быть числом</li>
                        <li>ID должен отличаться от текущего</li>
                        <li>Если iframe не загрузился — обновление не сработает</li>
                    </ul>

                    <h4>Визуальные подсказки:</h4>
                    <ul>
                        <li><span class="indicator yellow"></span> <strong>Жёлтая рамка</strong> — ID на странице соответствует введенному</li>
                        <li><span class="indicator green"></span> <strong>Зелёная рамка</strong> — обновление успешно</li>
                        <li><span class="indicator red"></span> <strong>Красная рамка</strong> — ошибка (ID не прошел валидацию)</li>
                    </ul>
                </div>

                <!-- Время пользователя -->
                <div id="timezone" class="sfua_howto_panel">
                    <h3>Время сессии в часовом поясе пользователя</h3>
                    <p>Отображает время начала сессии с учётом часового пояса пользователя.</p>

                    <h4>Как работает:</h4>
                    <ol>
                        <li>Расширение ищет регион пользователя в таблице информации (в AppMetrica)</li>
                        <li>Сравнивает его с базой <code>data/timezones.json</code></li>
                        <li>Если регион найден — рассчитывает смещение от UTC</li>
                        <li>Применяет смещение к времени сессии</li>
                        <li>Отображает результат в скобках рядом с датой</li>
                    </ol>

                    <h4>Пример отображения:</h4>
                    <pre style="background: #1e1e1e; padding: 12px; border-radius: 6px; font-family: monospace; margin: 10px 0;">
10 янв 2025, 15:23 (17:23)
                    </pre>
                    <p>Где <code>17:23</code> — время в часовом поясе пользователя.</p>

                    <h4>Условия отображения:</h4>
                    <ul>
                        <li>Регион должен быть указан в AppMetrica</li>
                        <li>Регион должен быть в файле <code>timezones.json</code></li>
                        <li>Если условие не выполнено — время не показывается</li>
                    </ul>

                    <h4>Особенности:</h4>
                    <ul>
                        <li>Работает в реальном времени — кнопка появляется при загрузке сессии</li>
                        <li>Поддерживает динамическую подгрузку (через <code>MutationObserver</code>)</li>
                    </ul>
                </div>
            </div>

            <!-- Футер -->
            <div class="sfua_howto_footer">
                <button class="sfua_howto_ok">Понятно</button>
            </div>
        </div>
    </div>
</body>
</html>


manifest.json:
--------------------------------------------------
{
  "manifest_version": 3,
  "name": "SFUA FE",
  "version": "6.3.52",
  "description": "Автоматизация анализа пользовательских сессий в Яндекс AppMetrica",
  "permissions": ["scripting", "activeTab", "storage", "tabs", "webNavigation"],
  "host_permissions": ["*://appmetrica.yandex.ru/*"],
  "background": {
    "service_worker": "background.js"
  },
  "content_scripts": [
    {
      "matches": ["*://appmetrica.yandex.ru/*"],
      "js": [
        "content/showcurrent.js",
        "content/usertimezone.js",
        "content/scrolltotop.js",
        "content/sync_manual_clicks.js"],
      "all_frames": true,
      "run_at": "document_end"
    }
  ],
"web_accessible_resources": [
  {
    "resources": [
      "data/timezones.json",
      "actions/*.js",
      "background/*.js",
      "content/styles/showcurrent.css",
      "background/styles/*.css",
      "content/styles/*.css",
      "content/*.js",
      "styles.css",
      "modal_error.js",
      "*.js",
      "*.css",
      "*.html"
    ],
    "matches": ["<all_urls>"]
  }
],
  "action": {
    "default_popup": "popup.html",
    "default_icon": {
      "16": "icons/icon16.png",
      "48": "icons/icon48.png",
      "128": "icons/icon128.png"
    }
  },
  "icons": {
    "16": "icons/icon16.png",
    "48": "icons/icon48.png",
    "128": "icons/icon128.png"
  }
}


how_to_use.css:
--------------------------------------------------
/* how_to_use.css — тёмная тема VS Code + фиксированная высота */

.sfua_howto_modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.6);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 2147483647;
    opacity: 0;
    transition: opacity 0.3s ease;
}

.sfua_howto_content {
    width: 48%;
    background: #1e1e1e; /* Фон VS Code */
    border-radius: 12px;
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.4);
    overflow: hidden;
    display: flex;
    flex-direction: column;
    height: 680px;
    transition: transform 0.3s ease;
}

/* Заголовок */
.sfua_howto_header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 16px 20px;
    background: #007acc; /* Синий заголовок как в VS Code */
    color: white;
    font-size: 16px;
    font-weight: 600;
    border-bottom: 1px solid #3c3c3c;
}

.sfua_howto_close {
    background: none;
    border: none;
    font-size: 24px;
    color: white;
    cursor: pointer;
    width: 30px;
    height: 30px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 50%;
    transition: background 0.2s ease;
}

.sfua_howto_close:hover {
    background: rgba(255, 255, 255, 0.2);
}

/* Вкладки */
.sfua_howto_tabs {
    display: flex;
    background: #1e1e1e; /* Фон VS Code */
    border-bottom: 1px solid #3c3c3c;
    font-size: 14px;
    font-weight: 500;
    overflow-x: auto;
    scrollbar-width: thin;
    margin: 0 auto;
}

.sfua_howto_tab {
    padding: 12px 16px;
    background: none;
    border: none;
    color: #d4d4d4;
    cursor: pointer;
    white-space: nowrap;
    transition: all 0.2s ease;
    border-bottom: 2px solid transparent;
}

.sfua_howto_tab.active {
    color: #007acc;
    border-bottom-color: #007acc;
}

.sfua_howto_tab:hover:not(.active) {
    color: #ffffff;
    background: rgba(255, 255, 255, 0.05);
}

/* Тело с фиксированной высотой и скроллом */
.sfua_howto_body {
    padding: 24px;
    color: #d4d4d4;
    line-height: 1.6;
    font-size: 14px;
    background: #252526;
    height: calc(680px - 180px);
    overflow-y: auto;
    overflow-x: hidden;
}

.sfua_howto_panel {
    display: none;
}

.sfua_howto_panel.active {
    display: block;
}

.sfua_howto_panel h3 {
    margin: 0 0 12px 0;
    color: #4fc1ff;
    font-weight: 600;
}

.sfua_howto_panel h4 {
    margin: 16px 0 8px 0;
    color: #7ea6e0;
    font-weight: 500;
}

.sfua_howto_panel ul {
    margin: 8px 0;
    padding-left: 20px;
}

.sfua_howto_panel code {
    background: #1e1e1e;
    color: #d4d4d4;
    padding: 2px 6px;
    border-radius: 4px;
    font-family: 'Courier New', monospace;
    font-size: 13px;
    border: 1px solid #3c3c3c;
}

/* Индикаторы цветов */
.indicator {
    display: inline-block;
    width: 12px;
    height: 12px;
    border-radius: 50%;
    margin-right: 8px;
    vertical-align: middle;
}

.indicator.green { background: #48bb78; }
.indicator.yellow { background: #ecc94b; }
.indicator.red { background: #e53e3e; }

/* Футер */
.sfua_howto_footer {
    padding: 16px 20px;
    text-align: center;
    background: #252526;
    border-top: 1px solid #3c3c3c;
}

.sfua_howto_ok {
    padding: 8px 20px;
    background: #007acc;
    color: white;
    border: none;
    border-radius: 6px;
    font-size: 14px;
    cursor: pointer;
    transition: background 0.2s ease;
}

.sfua_howto_ok:hover {
    background: #005a9e;
}

/* Скроллбар (в стиле VS Code) */
.sfua_howto_body::-webkit-scrollbar {
    width: 6px;
}

.sfua_howto_body::-webkit-scrollbar-track {
    background: #252526;
}

.sfua_howto_body::-webkit-scrollbar-thumb {
    background: #5a5a5a;
    border-radius: 3px;
}

.sfua_howto_body::-webkit-scrollbar-thumb:hover {
    background: #757575;
}


progress.css:
--------------------------------------------------
/* progress.css */

/* === Основной контейнер === */
.sfua_result_container {
    width: 100%;
    background: white;
    border: 1px solid #e2e8f0;
    border-radius: 8px;
    box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
    overflow: hidden;
    z-index: 10000;
    font-family: 'Segoe UI', sans-serif;
    font-size: 12px;
    color: #4a5568;
    position: relative;
    margin: 10px auto 8px;
    box-sizing: border-box;
}

/* Режим "закреплён" — фиксированная позиция И только если following */
.sfua_result_container.pinned.following {
    position: fixed;
    top: -40px;
    left: 25%;
    transform: translateX(-50%);
    width: 1200px;
    margin: 0 !important;
    z-index: 10001;
    animation: slideDown 0.3s forwards;
}

@keyframes slideDown {
    from { top: -40px; }
    to { top: 10px; }
}

.sfua_result_container.pinned:not(.following) {
    position: static;
    margin: 10px auto 8px;
}

/* Круги */
.sfua_result_container .circle_wrapper {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 20px;
    height: 20px;
}

.sfua_result_container .progress_circle {
    width: 20px;
    height: 20px;
    background-color: #edf2f7;
    border-radius: 50%;
    transition: all 0.2s ease;
}

/* Заголовок */
.sfua_result_container .progress_header {
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 8px 0;
    width: 100%;
}

.sfua_result_container .progress_circles {
    display: flex;
    gap: 10px;
    justify-content: center;
    margin-bottom: 6px;
    width: 100%;
    max-width: 180px;
}

.sfua_result_container .current_operation {
    text-align: center;
    font-weight: 500;
    font-size: 13px;
}

/* Результаты */
.sfua_result_container .results_container {
    display: flex;
    flex-wrap: wrap;
    gap: 6px;
    padding: 0 12px 8px;
    max-height: 100px;
    overflow-y: auto;
    justify-content: center;
}

/* Кнопки результатов */
.sfua_result_container .results_container .sfua_result_item {
    padding: 5px 10px;
    background-color: #f7fafc; /* Светлее, чем #edf2f7 */
    border-radius: 6px;
    font-size: 11px;
    font-weight: 500;
    color: #4a5568;
    cursor: pointer;
    white-space: nowrap;
    opacity: 0;
    transform: translateY(4px);
    transition: 
        opacity 0.2s ease,
        transform 0.2s ease;
}

/* Появление */
.sfua_result_container .results_container .sfua_result_item {
    opacity: 0;
    transform: translateY(4px);
}

.sfua_result_container .results_container .sfua_result_item:hover {
    background-color: rgb(203, 212, 221) !important;
    transform: translateY(0);
    box-shadow: 0 1px 3px rgba(66, 153, 225, 0.2);
    transition: 
        background-color 0.2s ease,
        color 0.2s ease,
        transform 0.1s ease,
        box-shadow 0.2s ease,
        border 0.2s ease;
}


allcode.py:
--------------------------------------------------
import os
import pathlib

def collect_files_content(folder_path, output_file="project_content.txt"):
    """
    Собирает содержимое всех файлов в папке и создает итоговый файл
    """
    # Поддерживаемые расширения файлов
    supported_extensions = {'.html', '.css', '.js','.json', '.xml'}
    
    # Получаем абсолютный путь к папке
    folder_path = os.path.abspath(folder_path)
    
    with open(output_file, 'w', encoding='utf-8') as output:
        # Сначала собираем все файлы
        all_files = []
        for root, dirs, files in os.walk(folder_path):
            for file in files:
                file_path = os.path.join(root, file)
                file_ext = pathlib.Path(file).suffix.lower()
                
                # Пропускаем системные файлы и сам выходной файл
                if (file.startswith('.') or file == output_file or 
                    file.startswith('__') or file == 'Thumbs.db'):
                    continue
                
                # Добавляем файл, даже если расширение не поддерживается
                all_files.append(file_path)
        
        # Обрабатываем файлы
        for file_path in all_files:
            try:
                relative_path = os.path.relpath(file_path, folder_path)
                file_ext = pathlib.Path(file_path).suffix.lower()
                
                # Записываем заголовок файла
                output.write(f"\n{relative_path}:\n")
                output.write("-" * 50 + "\n")
                
                # Читаем и записываем содержимое файла
                with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                    content = f.read()
                    output.write(content)
                    output.write("\n\n")
                    
            except Exception as e:
                output.write(f"Ошибка при чтении файла {file_path}: {str(e)}\n\n")
        
        # Добавляем структуру проекта в конце
        output.write("\n" + "="*60 + "\n")
        output.write("СТРУКТУРА ПРОЕКТА:\n")
        output.write("="*60 + "\n")
        generate_directory_tree(folder_path, output)

def generate_directory_tree(start_path, output_file, prefix=''):
    """
    Генерирует ASCII структуру каталогов
    """
    if not os.path.exists(start_path):
        output_file.write(f"Путь не существует: {start_path}\n")
        return
    
    if os.path.isfile(start_path):
        output_file.write(f"{prefix}📄 {os.path.basename(start_path)}\n")
        return
    
    items = os.listdir(start_path)
    items = [item for item in items if not item.startswith('.') and item != '__pycache__']
    items.sort()
    
    for i, item in enumerate(items):
        path = os.path.join(start_path, item)
        is_last = i == len(items) - 1
        
        if os.path.isdir(path):
            output_file.write(f"{prefix}{'└── ' if is_last else '├── '}📁 {item}/\n")
            new_prefix = prefix + ('    ' if is_last else '│   ')
            generate_directory_tree(path, output_file, new_prefix)
        else:
            output_file.write(f"{prefix}{'└── ' if is_last else '├── '}📄 {item}\n")

if __name__ == "__main__":
    # Укажите путь к вашей папке
    folder_to_scan = input("Введите путь к папке (или нажмите Enter для текущей папки): ").strip()
    
    if not folder_to_scan:
        folder_to_scan = "."
    
    if os.path.exists(folder_to_scan):
        output_filename = "project_content.txt"
        collect_files_content(folder_to_scan, output_filename)
        print(f"Файл {output_filename} успешно создан!")
    else:
        print("Указанная папка не существует!")


popup.html:
--------------------------------------------------
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>SFUA</title>
    <link rel="stylesheet" href="styles.css">
    <script src="popup.js" defer></script>
</head>
<body>
    <div class="sfua_container">
        <div class="section">
            <h3>Тип события</h3>
            <div class="event_types">
                <span class="event_type active">tap</span>
                <span class="event_type">open_screen</span>
                <span class="event_type">condition</span>
                <span class="event_type">event</span>
                <span class="event_type">authorization</span>
                <span class="event_type">tabbar</span>
                <span class="event_type">deeplink</span>
                <span class="event_type">tech</span>
                <span class="event_type">error</span>
                <span class="event_type">open_error</span>
                <span class="event_type">open_error_screen</span>
                <span class="event_type">errorMetric</span>
                <span class="event_type">offline_tap</span>
            </div>
        </div>

        <div class="section">
            <h3>Параметры</h3>
            <div class="params_row">
                <input class="param_key" type="text" value="%">
                <span class="equals">=</span>
                <input class="param_value" type="text" value="обновить данные">
            </div>
        </div>

        <!-- Кнопки в одной строке -->
        <div class="buttons_row">
            <button class="search_button">Начать поиск</button>
            <button class="error_search_button">
                <span class="error_icon"></span>
                <span class="error_text">Ошибки</span>
            </button>
        </div>

        <!-- Кнопка FAQ -->
        <div class="faq_row">
            <button class="faq_button">Краткое руководство</button>
        </div>
    </div>
</body>
</html>


popup.js:
--------------------------------------------------
// popup.js

document.addEventListener('DOMContentLoaded', async function () {
    const eventTypes = document.querySelectorAll('.event_type');
    const searchButton = document.querySelector('.search_button');
    const errorSearchButton = document.querySelector('.error_search_button');
    const paramKey = document.querySelector('.param_key');
    const paramValue = document.querySelector('.param_value');

    let currentTabId = null;

    // Получаем активную вкладку AppMetrica
    try {
        const tabs = await chrome.tabs.query({
            active: true,
            currentWindow: true,
            url: ['*://appmetrica.yandex.ru/*']
        });
        const appTab = tabs.find(tab => tab.url.includes('appmetrica.yandex.ru'));
        if (appTab) {
            currentTabId = appTab.id;
        }
    } catch (err) {
        console.error('SFUA: Ошибка получения вкладки:', err);
    }

    // Если AppMetrica не открыта
    if (!currentTabId) {
        document.querySelector('.sfua_container').innerHTML = `
            <div style="text-align: center; color: #718096; font-size: 12px; padding: 20px;">
                Откройте профиль пользователя в AppMetrica
            </div>
        `;
        return;
    }

    const STORAGE_KEY = `sfua_popup_state_tab_${currentTabId}`;
    const ERROR_SEARCH_DONE_KEY = `sfua_error_search_done_tab_${currentTabId}`;
    const SEARCH_IN_PROGRESS_KEY = `sfua_search_in_progress_tab_${currentTabId}`;

    // === Функции управления состоянием кнопки "Поиск ошибок" ===
    function disableErrorSearchButton() {
        errorSearchButton.disabled = true;
        errorSearchButton.style.opacity = '0.6';
        errorSearchButton.title = 'Поиск ошибок уже выполнен. Обновите страницу, чтобы запустить снова.';
    }

    function enableErrorSearchButton() {
        errorSearchButton.disabled = false;
        errorSearchButton.style.opacity = '1';
        errorSearchButton.title = 'Поиск всех ошибок (включая Крэш)';
    }

    // === Проверка состояния поиска ошибок ===
    async function checkErrorSearchState() {
        const result = await chrome.storage.local.get([ERROR_SEARCH_DONE_KEY]);
        const isDone = result[ERROR_SEARCH_DONE_KEY] === true;
        const hasActiveContainer = !!document.querySelector('.sfua_error_container');

        if (isDone && !hasActiveContainer) {
            // Поиск был завершён, но контейнера нет → можно запустить снова
            enableErrorSearchButton();
            // Очищаем устаревший флаг
            chrome.storage.local.remove(ERROR_SEARCH_DONE_KEY);
        } else if (isDone && hasActiveContainer) {
            // Поиск завершён и контейнер активен → нельзя запускать
            disableErrorSearchButton();
        } else {
            // Никаких следов поиска → разрешаем
            enableErrorSearchButton();
        }
    }

    // === Загрузка сохранённого состояния ===
    const result = await chrome.storage.local.get([STORAGE_KEY, ERROR_SEARCH_DONE_KEY, SEARCH_IN_PROGRESS_KEY]);
    const saved = result[STORAGE_KEY];

    if (saved) {
        eventTypes.forEach(type => {
            if (type.textContent.trim() === saved.eventType) {
                type.classList.add('active');
            } else {
                type.classList.remove('active');
            }
        });
        if (saved.key !== undefined) paramKey.value = saved.key;
        if (saved.value !== undefined) paramValue.value = saved.value;
    } else if (eventTypes.length > 0) {
        eventTypes[0].classList.add('active');
    }

    // === Проверка состояния обычного поиска ===
    if (result[SEARCH_IN_PROGRESS_KEY]) {
        searchButton.disabled = true;
        searchButton.textContent = 'Идёт поиск…';
        searchButton.title = 'Идёт поиск. Чтобы начать новый, нужно дождаться завершения или обновить страницу';
    } else {
        searchButton.title = 'Поиск событий по совпадению ключ:значение за выбранный период';
    }

    // === Переключение активного типа события ===
    eventTypes.forEach(type => {
        type.addEventListener('click', () => {
            eventTypes.forEach(t => t.classList.remove('active'));
            type.classList.add('active');
            saveState();
        });
    });

    paramKey.addEventListener('input', saveState);
    paramValue.addEventListener('input', saveState);

    // === Сохранение состояния ===
    function saveState() {
        const activeType = document.querySelector('.event_type.active');
        const state = {
            eventType: activeType ? activeType.textContent.trim() : 'tap',
            key: paramKey.value,
            value: paramValue.value
        };
        const changes = {};
        changes[STORAGE_KEY] = state;
        chrome.storage.local.set(changes);
    }

    // === Карта типов событий ===
    const typesMap = {
        'tap': 0, 'open_screen': 1, 'condition': 2, 'event': 3,
        'authorization': 4, 'tabbar': 5, 'deeplink': 6, 'tech': 7,
        'error': 8, 'open_error': 9, 'open_error_screen': 10,
        'errorMetric': 11, 'offline_tap': 12
    };

    // === Обработчик кнопки "Поиск ошибок" ===
    errorSearchButton.addEventListener('click', async () => {
        saveState();

        // Проверяем, существует ли вкладка
        let tab;
        try {
            tab = await chrome.tabs.get(currentTabId);
            if (!tab || !tab.url.includes('appmetrica.yandex.ru')) {
                alert('Вкладка AppMetrica не найдена или закрыта');
                return;
            }
        } catch (err) {
            console.error('SFUA: Вкладка не доступна:', err);
            alert('Не удалось получить доступ к вкладке');
            return;
        }

        // Проверяем, загружен ли iframe
        let iframeReady = false;
        try {
            const result = await chrome.scripting.executeScript({
                target: { tabId: currentTabId },
                func: () => {
                    const iframe = document.querySelector('iframe.iframe-integration__iframe');
                    return !!iframe && !!iframe.contentDocument?.body;
                }
            });
            iframeReady = result[0]?.result;
        } catch (e) {
            console.warn('SFUA: Ошибка проверки iframe:', e);
        }

        if (!iframeReady) {
            const retry = confirm('AppMetrica ещё не загружена. Подождать и попробовать снова?');
            if (retry) {
                errorSearchButton.disabled = true;
                errorSearchButton.textContent = 'Ожидание...';
                setTimeout(() => {
                    errorSearchButton.disabled = false;
                    errorSearchButton.textContent = 'Ошибки';
                    // Пользователь может нажать снова
                }, 3000);
            }
            return;
        }

        // Устанавливаем флаг
        chrome.storage.local.set({ [ERROR_SEARCH_DONE_KEY]: true }, () => {
            if (chrome.runtime.lastError) {
                console.warn('Не удалось сохранить состояние поиска ошибок:', chrome.runtime.lastError);
            } else {
                console.log('✅ Поиск ошибок помечен как выполненный');
            }
            disableErrorSearchButton();
        });

        // Отправляем запрос
        try {
            await chrome.runtime.sendMessage({
                action: "executeStartErrorSearch",
                tabId: currentTabId
            });
            console.log('✅ Сообщение "executeStartErrorSearch" отправлено');
            window.close();
        } catch (err) {
            console.error('SFUA: Ошибка отправки сообщения:', err);
            alert('Не удалось запустить поиск ошибок. Обновите страницу и попробуйте снова.');
        }
    });

    // === Обработчик кнопки "Начать поиск" ===
    async function startSearch(eventType, key, value) {
        saveState();

        // Блокируем кнопку
        searchButton.disabled = true;
        const originalText = searchButton.textContent;
        searchButton.textContent = 'Идёт поиск…';
        searchButton.title = 'Идёт поиск. Чтобы начать новый, нужно дождаться завершения или обновить страницу';

        // Устанавливаем флаг, что поиск идёт
        chrome.storage.local.set({ [SEARCH_IN_PROGRESS_KEY]: true }, () => {
            if (chrome.runtime.lastError) {
                console.warn('Не удалось сохранить состояние поиска:', chrome.runtime.lastError);
            }
        });

        // Сбрасываем флаги проверки параметров
        try {
            await chrome.runtime.sendMessage({
                action: "resetParamCheckFlags",
                tabId: currentTabId
            });
        } catch (err) {
            console.warn("SFUA: Не удалось сбросить флаги", err);
        }

        // Отправляем запрос на запуск поиска
        try {
            const response = await chrome.runtime.sendMessage({
                action: "startSearch",
                eventType: eventType,
                key: key,
                value: value,
                tabId: currentTabId
            });

            if (response && !response.success) {
                throw new Error(response.error);
            }

            // Через 1 сек разблокируем кнопку
            setTimeout(() => {
                if (searchButton.disabled) {
                    searchButton.disabled = false;
                    searchButton.textContent = originalText;
                    searchButton.title = 'Поиск событий по совпадению ключ:значение за выбранный период';
                }
                // Удаляем флаг
                chrome.storage.local.remove(SEARCH_IN_PROGRESS_KEY);
            }, 1000);

            window.close();

        } catch (error) {
            console.error('SFUA: Ошибка при запуске поиска:', error);
            setTimeout(() => {
                if (searchButton.disabled) {
                    searchButton.disabled = false;
                    searchButton.textContent = originalText;
                    searchButton.title = 'Поиск событий по совпадению ключ:значение за выбранный период';
                }
                chrome.storage.local.remove(SEARCH_IN_PROGRESS_KEY);
            }, 3000);
        }
    }

    searchButton.addEventListener('click', () => {
        const activeType = document.querySelector('.event_type.active');
        if (!activeType) return;
        const typeName = activeType.textContent.trim();
        const eventType = typesMap[typeName] ?? 0;
        startSearch(eventType, paramKey.value, paramValue.value);
    });

// === Обработчик кнопки FAQ ===
const faqButton = document.querySelector('.faq_button');
if (faqButton) {
    faqButton.addEventListener('click', () => {
        console.log('[Popup] Открываем FAQ на странице');
        chrome.runtime.sendMessage({
            action: "showHowToUse"
        });
        window.close();
    });
}

function injectHowToUse() {
    const script = document.createElement('script');
    script.src = chrome.runtime.getURL('how_to_use.js');
    script.onload = () => script.remove();
    (document.head || document.documentElement).appendChild(script);
}

    // === Горячие клавиши: Ctrl+Enter ===
    function handleCtrlEnter(e) {
        if (e.key === 'Enter' && (e.ctrlKey || e.metaKey)) {
            e.preventDefault();
            const activeType = document.querySelector('.event_type.active');
            if (!activeType) return;
            const typeName = activeType.textContent.trim();
            const eventType = typesMap[typeName] ?? 0;
            startSearch(eventType, paramKey.value, paramValue.value);
        }
    }

    paramKey.addEventListener('keydown', handleCtrlEnter);
    paramValue.addEventListener('keydown', handleCtrlEnter);

    // === Проверка состояния при старте ===
    checkErrorSearchState();

    // === Следим за обновлением вкладки ===
    chrome.tabs.onUpdated.addListener((tabId, changeInfo, tab) => {
        if (tabId === currentTabId && changeInfo.status === 'complete' && tab.url.includes('appmetrica.yandex.ru')) {
            console.log('[Popup] Вкладка обновлена — проверяем состояние поиска ошибок');
            checkErrorSearchState();
        }
    });

    // === Следим за активацией вкладки ===
    chrome.tabs.onActivated.addListener(async (activeInfo) => {
        if (activeInfo.tabId === currentTabId) {
            try {
                const tab = await chrome.tabs.get(currentTabId);
                if (tab.url?.includes('appmetrica.yandex.ru')) {
                    console.log('[Popup] Вкладка активирована — проверяем состояние');
                    checkErrorSearchState();
                }
            } catch (e) {
                console.warn('Не удалось получить вкладку:', e);
            }
        }
    });
});


content/sync_manual_clicks.js:
--------------------------------------------------
// sync_manual_clicks.js

(function () {
    console.log('SFUA: sync_manual_clicks.js — запущен');

    // === Обработчик кликов по span.link__inner ===
    document.addEventListener('click', function (e) {
        const target = e.target;

        // Проверяем, что это span с классом link__inner
        if (target.classList.contains('link__inner')) {
            e.preventDefault();
            e.stopPropagation();

            // Переключаем класс span_checked
            if (target.classList.contains('span_checked')) {
                target.classList.remove('span_checked');
            } else {
                target.classList.add('span_checked');
            }

            // 🔔 Опционально: можно отправить событие для других скриптов
            // Например, если другие скрипты должны реагировать
            target.dispatchEvent(new CustomEvent('sfua:spanToggled', {
                bubbles: true,
                detail: { checked: target.classList.contains('span_checked') }
            }));
        }
    });
    const observer = new MutationObserver(() => {
        // Можно переназначить обработчики, если элементы подгружаются динамически
        // Но в данном случае — достаточно делегирования на document
    });

    observer.observe(document.body, {
        childList: true,
        subtree: true
    });

    console.log('SFUA: Обработчик кликов по link__inner активен');
})();


content/showcurrent.js:
--------------------------------------------------
// content/showcurrent.js

if (!window.__SFUA_SHOWCURRENT_LOADED__) {
    window.__SFUA_SHOWCURRENT_LOADED__ = true;

    console.log('SFUA ShowCurrent инициализирован (v3.3)');

    window.__SFUA__ = window.__SFUA__ || {};
    window.__SFUA__.globalSessionCounter = window.__SFUA__.globalSessionCounter || 0;
    window.__SFUA__.observer = null;

    const mainStyles = `
        [class^="btn_current_"] {
            color: #04b;
            cursor: pointer;
            font-size: 12px;
            margin-left: 10px;
            display: inline-block;
        }
        [class^="btn_current_"]:hover { opacity: 0.8; }
        [class^="btn_current_"][data-state="loading"] {
            color: #555;
            cursor: default;
            pointer-events: none;
        }
        [class^="btn_current_"][data-state="done"] {
            color: #0a0;
            cursor: default;
        }
    `;

    const ALLOWED_ELEMENTS = new Set([
        'tap', 'condition', 'open_screen', 'event', 'tabbar', 'authorization',
        'offline_tap', 'offline_open_screen', 'errorMetric', 'error', 'Deeplink',
        'tech', 'push', 'open_error_screen', 'deeplink'
    ]);

    function checkHasAnyClickable(sessionElement) {
        const buttons = sessionElement.querySelectorAll('span.link__inner');
        for (const btn of buttons) {
            const text = btn.textContent.trim();
            if (
                /^(Все \d+ событи[яей]|Все \d+)$/.test(text) ||
                /^\+\d+$/.test(text) ||
                ALLOWED_ELEMENTS.has(text)
            ) {
                return true;
            }
        }
        return false;
    }

    function addStyles(doc) {
        if (doc.querySelector('link[data-sfua-showcurrent]')) return;

        const link = doc.createElement('link');
        link.rel = 'stylesheet';
        link.href = chrome.runtime.getURL('content/styles/showcurrent.css');
        link.setAttribute('data-sfua-showcurrent', 'true');

        link.onerror = () => console.error('SFUA SHOWCURRENT: Не удалось загрузить CSS');
        link.onload = () => console.log('SFUA SHOWCURRENT: Стили загружены');

        doc.head.appendChild(link);
    }

    function processSessionElements(doc, isNew = false) {
        const selector = 'div.profile-session_js_inited:not([class*="current_parent_"])';
        const sessionElements = doc.querySelectorAll(selector);

        console.log(`SFUA SHOWCURRENT: Найдено ${sessionElements.length} сессий`);

        if (sessionElements.length === 0) return;

        let itemsProcessed = 0;
        sessionElements.forEach(element => {
            const className = `current_parent_${window.__SFUA__.globalSessionCounter}`;
            element.classList.add(className);

            const dateElement = element.querySelector('div.profile-session__date');
            if (!dateElement) {
                window.__SFUA__.globalSessionCounter++;
                return;
            }

            const hasAnyClickable = checkHasAnyClickable(element);

            if (hasAnyClickable) {
                if (!dateElement.nextElementSibling?.classList?.contains(`btn_current_${window.__SFUA__.globalSessionCounter}`)) {
                    const button = doc.createElement('div');
                    button.className = `btn_current_${window.__SFUA__.globalSessionCounter}`;
                    button.textContent = "Развернуть события сессии";
                    button.addEventListener('click', handleButtonClick);
                    dateElement.insertAdjacentElement('afterend', button);
                    itemsProcessed++;
                }
            } else {
                const nextEl = dateElement.nextElementSibling;
                if (!nextEl || !nextEl.classList?.contains('sfua_no_events_placeholder')) {
                    if (nextEl && nextEl.classList?.contains('sfua_no_events_placeholder')) {
                        nextEl.remove();
                    }
                    const placeholder = doc.createElement('div');
                    placeholder.className = 'sfua_no_events_placeholder';
                    placeholder.textContent = "События отсутствуют";
                    placeholder.style.cssText = 'display: inline-block; font-size: 12px; color: #a0aec0; margin-left: 10px; user-select: none;';
                    dateElement.insertAdjacentElement('afterend', placeholder);
                    itemsProcessed++;
                }
            }

            window.__SFUA__.globalSessionCounter++;
        });

        console.log(`SFUA SHOWCURRENT: Обработано сессий: ${itemsProcessed}`);
    }

    function setupMutationObserver(doc) {
        if (window.__SFUA__.observer) {
            window.__SFUA__.observer.disconnect();
        }

        window.__SFUA__.observer = new MutationObserver(mutations => {
            mutations.forEach(mutation => {
                if (mutation.addedNodes.length) {
                    processSessionElements(doc, true);
                }
            });
        });

        window.__SFUA__.observer.observe(doc.body, {
            childList: true,
            subtree: true
        });
    }

    function delay(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    // === ЕДИНЫЙ МЕТОД КЛИКА С ДОБАВЛЕНИЕМ КЛАССА ===
    function simulateClickWithCheck(element) {
        if (!element || element.classList.contains('span_checked')) {
            return;
        }

        // 1. Кликаем
        element.click();

        // 2. Добавляем класс — как при ручном клике
        element.classList.add('span_checked');

        // 3. Можно отправить событие
        element.dispatchEvent(new CustomEvent('sfua:spanToggled', {
            bubbles: true,
            detail: { checked: true }
        }));
    }

    async function handleButtonClick(event) {
        event.preventDefault();
        event.stopPropagation();

        const button = event.currentTarget;
        const currentState = button.getAttribute('data-state');
        if (currentState === 'loading' || currentState === 'done') return;

        console.log(`SFUA SHOWCURRENT: Нажата кнопка ${button.className}`);
        button.setAttribute('data-state', 'loading');
        button.textContent = "Загрузка...";

        try {
            const sessionIndex = parseInt(button.className.split('_').pop());
            const parent = button.ownerDocument.querySelector(`.current_parent_${sessionIndex}`);
            if (!parent) throw new Error('Parent not found');

            // 1. "Все N событий"
            const allEventsButtons = [...parent.querySelectorAll('span.link__inner')]
            .filter(btn => 
                /^(Все \d+ событи[яей]|Все \d+)$/.test(btn.textContent.trim()) &&
                !btn.classList.contains('span_checked')
            );
            console.log(`"Все N": ${allEventsButtons.length}`);
            for (const btn of allEventsButtons) {
                simulateClickWithCheck(btn);
                console.log(`Клик по "${btn.textContent.trim()}"`);
                await delay(2000);
            }

            // 2. "+N"
            const plusButtons = [...parent.querySelectorAll('span.link__inner')]
                .filter(btn => 
                    /^\+\d+$/.test(btn.textContent.trim()) &&
                    !btn.classList.contains('span_checked')
                );
            console.log(`"+N": ${plusButtons.length}`);
            for (const btn of plusButtons) {
                simulateClickWithCheck(btn);
                console.log(`Клик по "${btn.textContent.trim()}"`);
                await delay(300 + Math.random() * 200);
            }

            if (plusButtons.length) await delay(1000);

            // 3. ALLOWED_ELEMENTS
            const otherButtons = [...parent.querySelectorAll('span.link__inner')]
                .filter(btn => 
                    ALLOWED_ELEMENTS.has(btn.textContent.trim()) &&
                    !btn.classList.contains('span_checked')
                );
            console.log(`Разрешённые: ${otherButtons.length}`);
            for (const btn of otherButtons) {
                simulateClickWithCheck(btn);
                console.log(`Клик по "${btn.textContent.trim()}"`);
                await delay(300 + Math.random() * 200);
            }

            button.setAttribute('data-state', 'done');
            button.textContent = "События загружены";

        } catch (error) {
            console.error('SFUA Error:', error);
            button.textContent = "Ошибка!";
            button.removeAttribute('data-state');
        }
    }

    function initForDocument(doc) {
        addStyles(doc);
        processSessionElements(doc);
        setupMutationObserver(doc);

        setTimeout(() => processSessionElements(doc, true), 3000);
    }

    function initialize() {
        initForDocument(document);

        window.addEventListener('unload', () => {
            if (window.__SFUA__.observer) window.__SFUA__.observer.disconnect();
        });
    }

    if (document.readyState === 'complete' || document.readyState === 'interactive') {
        setTimeout(initialize, 0);
    } else {
        document.addEventListener('DOMContentLoaded', initialize);
        window.addEventListener('load', initialize);
    }
} else {
    console.log('SFUA SHOWCURRENT: Уже загружен');
}


content/usertimezone.js:
--------------------------------------------------
// content/usertimezone.js

(function () {
    // Защита от двойного выполнения
    if (window.sfua_usertimezone_loaded) {
        console.log('[SFUA TIMEZONE] Уже загружен — пропускаем');
        return;
    }
    window.sfua_usertimezone_loaded = true;

    const CONFIG = {
        logPrefix: '[SFUA TIMEZONE]',
        checkInterval: 200,
        maxRetries: 50,
        animationDuration: 700, // 0.7s
        animationEasing: 'cubic-bezier(0.4, 0, 0.2, 1)'
    };

    let timezoneOffset = null;
    let isInitialized = false;
    let observer = null;
    let interval = null;

    async function initTimezoneHandler() {
        if (isInitialized) {
            console.log(`${CONFIG.logPrefix} Уже инициализирован — пропускаем`);
            return;
        }

        console.log(`${CONFIG.logPrefix} Инициализация`);

        try {
            // ✅ Ищем .userinfo_timezone ВО ВСЕМ документе (включая iframe и родитель)
            timezoneOffset = await findTimezoneOffset();
            if (timezoneOffset === null) {
                console.error(`${CONFIG.logPrefix} Не удалось получить часовой пояс`);
                return;
            }

            console.log(`${CONFIG.logPrefix} Найдена разница в часовом поясе: ${timezoneOffset} от МСК`);

            // ✅ Начинаем обработку
            processExistingDates();
            setupObservation();

            isInitialized = true;

        } catch (error) {
            console.error(`${CONFIG.logPrefix} Ошибка инициализации:`, error);
        }
    }

    // ✅ Ищем .userinfo_timezone везде: в iframe и в родительском документе
    function findTimezoneOffset() {
        return new Promise((resolve) => {
            let retries = 0;

            const tryFind = () => {
                if (isInitialized) {
                    resolve(null);
                    return;
                }

                // 1. Ищем в iframe
                const iframe = document.querySelector('iframe.iframe-integration__iframe');
                if (iframe && iframe.contentDocument) {
                    const el = iframe.contentDocument.querySelector('.userinfo_timezone');
                    if (el) {
                        const offset = parseTimezone(el.textContent);
                        if (offset !== null) {
                            resolve(offset);
                            return;
                        }
                    }
                }

                // 2. Ищем в родительском документе
                const elInParent = document.querySelector('.userinfo_timezone');
                if (elInParent) {
                    const offset = parseTimezone(elInParent.textContent);
                    if (offset !== null) {
                        resolve(offset);
                        return;
                    }
                }

                // 3. Повторяем
                if (retries++ < CONFIG.maxRetries) {
                    setTimeout(tryFind, CONFIG.checkInterval);
                } else {
                    console.warn(`${CONFIG.logPrefix} Элемент .userinfo_timezone нигде не найден`);
                    resolve(null);
                }
            };

            tryFind();
        });
    }

    function parseTimezone(text) {
        if (!text) return null;
        const cleaned = text.trim();
        const sign = cleaned.includes('-') ? -1 : 1;
        const numbers = cleaned.replace(/\D/g, '');
        const value = parseInt(numbers);
        return isNaN(value) ? null : sign * value;
    }

    function processExistingDates() {
        const dateElements = document.querySelectorAll('.profile-session__date');
        console.log(`${CONFIG.logPrefix} Найдено ${dateElements.length} элементов с датой/временем сессии`);
        dateElements.forEach(el => {
            if (!el.querySelector('.user_sessiontime')) {
                updateDateElement(el);
            }
        });
    }

    function updateDateElement(element) {
        if (element.dataset.timezoneProcessed) return;
        const originalText = element.textContent.trim();
        if (!originalText.includes(' в ')) return;

        try {
            const adjustedTime = adjustTime(originalText);
            const span = document.createElement('span');
            span.className = 'user_sessiontime';
            span.textContent = ` (${adjustedTime})`;
            span.title = 'Время сессии в часовом поясе пользователя';

            // === Стили для анимации справа налево ===
            span.style.cssText = `
                font-size: 18px;
                font-weight: 700;
                color: rgba(0, 0, 0, .35);
                margin-left: 4px;
                cursor: default;
                display: inline-block;
                transform: scale(0);
                transform-origin: right center; /* Ключ: масштабирование справа */
                transition: transform ${CONFIG.animationDuration}ms ${CONFIG.animationEasing};
            `;

            element.appendChild(span);
            element.dataset.timezoneProcessed = 'true';
            console.log(`${CONFIG.logPrefix} Добавлено время пользователя: ${adjustedTime}`);

            // === АНИМАЦИЯ: scale(0) → scale(1) ===
            requestAnimationFrame(() => {
                setTimeout(() => {
                    span.style.transform = 'scale(1)';
                }, 10);
            });

        } catch (e) {
            console.error(`${CONFIG.logPrefix} Ошибка обработки даты:`, e);
        }
    }

    function adjustTime(dateString) {
        const MONTHS = {
            'Января': 0, 'Февраля': 1, 'Марта': 2, 'Апреля': 3,
            'Мая': 4, 'Июня': 5, 'Июля': 6, 'Августа': 7,
            'Сентября': 8, 'Октября': 9, 'Ноября': 10, 'Декабря': 11
        };

        const [datePart, timePart] = dateString.split(' в ');
        const [hours, minutes] = timePart.split(':').map(Number);
        const now = new Date();
        let date = new Date();

        if (datePart === 'Сегодня') {
            // оставляем текущую дату
        } else if (datePart === 'Вчера') {
            date.setDate(date.getDate() - 1);
        } else {
            const [day, monthName] = datePart.split(' ');
            date.setMonth(MONTHS[monthName], parseInt(day));
            date.setFullYear(now.getFullYear());
        }

        date.setHours(hours, minutes, 0, 0);
        const adjustedDate = new Date(date.getTime() + timezoneOffset * 3600000);
        return `${adjustedDate.getHours().toString().padStart(2, '0')}:${adjustedDate.getMinutes().toString().padStart(2, '0')}`;
    }

    function setupObservation() {
        if (observer) observer.disconnect();
        if (interval) clearInterval(interval);

        observer = new MutationObserver((mutations) => {
            mutations.forEach((mutation) => {
                mutation.addedNodes.forEach((node) => {
                    if (node.nodeType === Node.ELEMENT_NODE) {
                        if (node.matches('.profile-session__date')) {
                            updateDateElement(node);
                        }
                        node.querySelectorAll('.profile-session__date').forEach(updateDateElement);
                    }
                });
            });
        });

        observer.observe(document.body, {
            childList: true,
            subtree: true
        });

        interval = setInterval(() => {
            if (isInitialized) {
                const newElements = document.querySelectorAll('.profile-session__date:not([data-timezone-processed])');
                if (newElements.length > 0) {
                    console.log(`${CONFIG.logPrefix} Найдено ${newElements.length} новых элементов`);
                    newElements.forEach(updateDateElement);
                }
            }
        }, CONFIG.checkInterval);

        console.log(`${CONFIG.logPrefix} Наблюдение за DOM запущено`);
    }

    function start() {
        if (document.readyState === 'complete') {
            initTimezoneHandler();
        } else {
            document.addEventListener('DOMContentLoaded', initTimezoneHandler);
        }

        // Принудительная проверка
        setTimeout(() => {
            if (!isInitialized && !document.querySelector('.user_sessiontime')) {
                console.log(`${CONFIG.logPrefix} Принудительная проверка`);
                initTimezoneHandler();
            }
        }, 3000);
    }

    start();

})();


content/scrolltotop.js:
--------------------------------------------------
// content/scrolltotop.js

(function () {
    console.log("ScrollToTop: Инициализация");

    // === Параметры ===
    const SHOW_THRESHOLD = 300;  // Показать при прокрутке >300px
    const HIDE_THRESHOLD = 500;  // Скрыть при прокрутке <500px
    const ANIMATION_DURATION = 1500; // 1.5 сек

    // === Создаём кнопку ===
    const button = document.createElement('button');
    button.className = 'sfua_scroll_to_top';
    button.style.cssText = `
        position: fixed;
        bottom: -100px;
        right: -100px;
        width: 40px;
        height: 40px;
        border: none;
        border-radius: 20%;
        background-color: #edf2f7;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        cursor: pointer;
        z-index: 10000;
        opacity: 0;
        transform: scale(0);
        transition: all 0.4s ease;
        display: flex;
        align-items: center;
        justify-content: center;
    `;

    // SVG стрелка вверх (серая)
    const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    svg.setAttribute('width', '32');
    svg.setAttribute('height', '32');
    svg.setAttribute('viewBox', '0 0 24 24');
    svg.setAttribute('fill', 'none');
    svg.setAttribute('stroke', '#4a5568');
    svg.setAttribute('stroke-width', '2');
    svg.setAttribute('stroke-linecap', 'round');
    svg.setAttribute('stroke-linejoin', 'round');

    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    line.setAttribute('x1', '12');
    line.setAttribute('y1', '19');
    line.setAttribute('x2', '12');
    line.setAttribute('y2', '5');

    const polyline = document.createElementNS('http://www.w3.org/2000/svg', 'polyline');
    polyline.setAttribute('points', '5 12 12 5 19 12');

    svg.appendChild(line);
    svg.appendChild(polyline);
    button.appendChild(svg);

    // Добавляем в body
    document.body.appendChild(button);

    // === Управление видимостью ===
    let isVisible = false;

    function updateButton() {
        const scrollTop = window.pageYOffset || document.documentElement.scrollTop;

        if (scrollTop >= SHOW_THRESHOLD && !isVisible) {
            // Показать с анимацией
            button.style.bottom = '60px';
            button.style.right = '100px';
            button.style.opacity = '1';
            button.style.transform = 'scale(1)';
            isVisible = true;
        } else if (scrollTop < HIDE_THRESHOLD && isVisible) {
            // Скрыть с анимацией
            button.style.opacity = '0';
            button.style.transform = 'scale(0)';
            setTimeout(() => {
                if (!isVisible) {
                    button.style.bottom = '-100px';
                    button.style.right = '-100px';
                }
            }, ANIMATION_DURATION);
            isVisible = false;
        }
    }

    // === Прокрутка наверх ===
    button.addEventListener('click', () => {
        window.scrollTo({
            top: 0,
            behavior: 'smooth'
        });
    });

    // === Слушаем прокрутку ===
    window.addEventListener('scroll', () => {
        requestAnimationFrame(updateButton);
    });

    // === Инициализация ===
    updateButton();

    console.log("ScrollToTop: Готов");
})();


content/styles/showcurrent.css:
--------------------------------------------------
[class^="btn_current_"] {
    color: #04b;
    cursor: pointer;
    font-size: 12px;
    margin-left: 10px;
    display: inline-block;
}

[class^="btn_current_"]:hover {
    opacity: 0.8;
}

[class^="btn_current_"][data-state="loading"]
{
    color: #555;
    cursor: default;
    pointer-events: none;
    opacity: 1;
}
[class^="btn_current_"][data-state="done"] {
    color: #0a0;
    cursor: default;
    pointer-events: none;
    opacity: 1;
}


icons/icon48.png:
--------------------------------------------------
PNG

   
IHDR   0   0   W   	pHYs  .#  .#x?v  
iTXtXML:com.adobe.xmp     <?xpacket begin="﻿" id="W5M0MpCehiHzreSzNTczkc9d"?> <x:xmpmeta xmlns:x="adobe:ns:meta/" x:xmptk="Adobe XMP Core 6.0-c003 116.ddc7bc4, 2021/08/17-13:18:37        "> <rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"> <rdf:Description rdf:about="" xmlns:xmp="http://ns.adobe.com/xap/1.0/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:xmpMM="http://ns.adobe.com/xap/1.0/mm/" xmlns:stEvt="http://ns.adobe.com/xap/1.0/sType/ResourceEvent#" xmlns:stRef="http://ns.adobe.com/xap/1.0/sType/ResourceRef#" xmlns:photoshop="http://ns.adobe.com/photoshop/1.0/" xmlns:tiff="http://ns.adobe.com/tiff/1.0/" xmlns:exif="http://ns.adobe.com/exif/1.0/" xmp:CreatorTool="Adobe Photoshop 21.2 (Windows)" xmp:CreateDate="2025-05-27T20:00:26+04:00" xmp:MetadataDate="2025-05-29T08:48:09+04:00" xmp:ModifyDate="2025-05-29T08:48:09+04:00" dc:format="image/png" xmpMM:InstanceID="xmp.iid:a25492f0-cef9-104d-871f-6ac9d48de367" xmpMM:DocumentID="adobe:docid:photoshop:ab53913c-b985-e94c-86f5-d1ed83954569" xmpMM:OriginalDocumentID="xmp.did:a90bc5b9-7cea-af49-a9ed-f1346aff474b" photoshop:ColorMode="3" photoshop:ICCProfile="sRGB IEC61966-2.1" tiff:Orientation="1" tiff:XResolution="3000000/10000" tiff:YResolution="3000000/10000" tiff:ResolutionUnit="2" exif:ColorSpace="65535" exif:PixelXDimension="231" exif:PixelYDimension="231"> <xmpMM:History> <rdf:Seq> <rdf:li stEvt:action="created" stEvt:instanceID="xmp.iid:a90bc5b9-7cea-af49-a9ed-f1346aff474b" stEvt:when="2025-05-27T20:00:26+04:00" stEvt:softwareAgent="Adobe Photoshop 21.2 (Windows)"/> <rdf:li stEvt:action="saved" stEvt:instanceID="xmp.iid:ccc09a5f-f29a-3744-a216-64cd058a4f66" stEvt:when="2025-05-29T08:47:26+04:00" stEvt:softwareAgent="Adobe Photoshop 21.2 (Windows)" stEvt:changed="/"/> <rdf:li stEvt:action="saved" stEvt:instanceID="xmp.iid:48189c3c-7194-6841-a888-78a35e7acfff" stEvt:when="2025-05-29T08:48:09+04:00" stEvt:softwareAgent="Adobe Photoshop 21.2 (Windows)" stEvt:changed="/"/> <rdf:li stEvt:action="converted" stEvt:parameters="from application/vnd.adobe.photoshop to image/png"/> <rdf:li stEvt:action="derived" stEvt:parameters="converted from application/vnd.adobe.photoshop to image/png"/> <rdf:li stEvt:action="saved" stEvt:instanceID="xmp.iid:a25492f0-cef9-104d-871f-6ac9d48de367" stEvt:when="2025-05-29T08:48:09+04:00" stEvt:softwareAgent="Adobe Photoshop 21.2 (Windows)" stEvt:changed="/"/> </rdf:Seq> </xmpMM:History> <xmpMM:DerivedFrom stRef:instanceID="xmp.iid:48189c3c-7194-6841-a888-78a35e7acfff" stRef:documentID="xmp.did:a90bc5b9-7cea-af49-a9ed-f1346aff474b" stRef:originalDocumentID="xmp.did:a90bc5b9-7cea-af49-a9ed-f1346aff474b"/> </rdf:Description> </rdf:RDF> </x:xmpmeta> <?xpacket end="r"?>(G  ^IDAThřm\UϹ/3vv]ZJH%$AT0@
Ĩ1HIK-j I}E!nwk]:n;;l[I&>s(+ҜDEA[mP& *>@^D({sxWvT|cʙ*kޭwDNɲ1C)JƈlW>hK/Ŷ֦h#xDNJ
QӶx=JBcYhc hsOm||-R{g}! @kE}jQ	bFm3̏Z rƏtONۿ?/|NO{zCYD QòQXF^ᔟu+w91(Z̑0ӂgѱ.'x׭)?^]6
: hH#ܑ]~#BoB_Fw:7w$TFXa Qhv2Vhâ @Y+e}naj;6Hus@ ($ߖ޶\Xx=P*Wjr q/k첪Jl^\aMUkH:YLÀrEUlK >"HU-
5Ѭ(Py,-Sye/j|fu+Lt@cph4|ADp#NPIs/ jV6X6Ļb/{ ;$N1AZkTp{(fwmEiY=ڿ?:t˲PBu] ```wڿ5fPU"09=sd2H$h/x5S,翜эX.
81?zΆT*D"KcXL&H}C;p〪engybK",̗:2]+!wnʂ?LJhooAcH$?~T*_ȟΕ(w-|ppu6qV>|xq{(nr7-fdh	=GT*-!7ynn_0B'1x<N:^8qυݪH^(QZehh'R
۶FVQYLzSCGGd:gؤFz%8pntv
8n1vR#=6ko:-ԧeř2wqLpZ5*$1bw^ &aüu8ґ&nja(ͯxG5bj|HN\qq~4>|cp
O}jTa:3UXO@X(0
v됙 )h6l˂m֧2L,N<D{KqBM컍]_cC
 #pe~dz!	'"O&ہQ`yݍVQ}Wa	@>WekG ~;R:x@R8LpO͟<wcӰ˚@~ت4_/gL8碪vo*4l/(Gj,ر(+ʐ;l/TF_]c(4	 ewʁqo6	m9'v!KI\jZs "O&g^hLt9J[O<(j53!(/*j[RR|²^~	Vצӣ[wRͱD{3Voc4@v/ndmǗŚƳuX
TsKW	'dor iࡖ(Ćl+?3nap&J+RGi-Q`0Vy>^>[v/oD'
+tKLzy -ъd^_iXp nU}%#}@zAp#͜]-jj{!4
<lN7ٿN|mn+6.Nv3
;ȴ*`E'(n  =@߾$/ֳv60    IENDB`


icons/icon16.png:
--------------------------------------------------
PNG

   
IHDR         a   	pHYs  .#  .#x?v  
iTXtXML:com.adobe.xmp     <?xpacket begin="﻿" id="W5M0MpCehiHzreSzNTczkc9d"?> <x:xmpmeta xmlns:x="adobe:ns:meta/" x:xmptk="Adobe XMP Core 6.0-c003 116.ddc7bc4, 2021/08/17-13:18:37        "> <rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"> <rdf:Description rdf:about="" xmlns:xmp="http://ns.adobe.com/xap/1.0/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:xmpMM="http://ns.adobe.com/xap/1.0/mm/" xmlns:stEvt="http://ns.adobe.com/xap/1.0/sType/ResourceEvent#" xmlns:stRef="http://ns.adobe.com/xap/1.0/sType/ResourceRef#" xmlns:photoshop="http://ns.adobe.com/photoshop/1.0/" xmlns:tiff="http://ns.adobe.com/tiff/1.0/" xmlns:exif="http://ns.adobe.com/exif/1.0/" xmp:CreatorTool="Adobe Photoshop 21.2 (Windows)" xmp:CreateDate="2025-05-27T20:00:26+04:00" xmp:MetadataDate="2025-05-29T08:48:23+04:00" xmp:ModifyDate="2025-05-29T08:48:23+04:00" dc:format="image/png" xmpMM:InstanceID="xmp.iid:2bc1c45a-bab8-d542-82c0-03e24474977e" xmpMM:DocumentID="adobe:docid:photoshop:5d9d4e85-c2d4-ee4a-a5aa-5a19d836b39e" xmpMM:OriginalDocumentID="xmp.did:a90bc5b9-7cea-af49-a9ed-f1346aff474b" photoshop:ColorMode="3" photoshop:ICCProfile="sRGB IEC61966-2.1" tiff:Orientation="1" tiff:XResolution="3000000/10000" tiff:YResolution="3000000/10000" tiff:ResolutionUnit="2" exif:ColorSpace="65535" exif:PixelXDimension="231" exif:PixelYDimension="231"> <xmpMM:History> <rdf:Seq> <rdf:li stEvt:action="created" stEvt:instanceID="xmp.iid:a90bc5b9-7cea-af49-a9ed-f1346aff474b" stEvt:when="2025-05-27T20:00:26+04:00" stEvt:softwareAgent="Adobe Photoshop 21.2 (Windows)"/> <rdf:li stEvt:action="saved" stEvt:instanceID="xmp.iid:ccc09a5f-f29a-3744-a216-64cd058a4f66" stEvt:when="2025-05-29T08:47:26+04:00" stEvt:softwareAgent="Adobe Photoshop 21.2 (Windows)" stEvt:changed="/"/> <rdf:li stEvt:action="saved" stEvt:instanceID="xmp.iid:26ebb4c7-3ea9-6e4e-a2e0-5f8686aab1ea" stEvt:when="2025-05-29T08:48:23+04:00" stEvt:softwareAgent="Adobe Photoshop 21.2 (Windows)" stEvt:changed="/"/> <rdf:li stEvt:action="converted" stEvt:parameters="from application/vnd.adobe.photoshop to image/png"/> <rdf:li stEvt:action="derived" stEvt:parameters="converted from application/vnd.adobe.photoshop to image/png"/> <rdf:li stEvt:action="saved" stEvt:instanceID="xmp.iid:2bc1c45a-bab8-d542-82c0-03e24474977e" stEvt:when="2025-05-29T08:48:23+04:00" stEvt:softwareAgent="Adobe Photoshop 21.2 (Windows)" stEvt:changed="/"/> </rdf:Seq> </xmpMM:History> <xmpMM:DerivedFrom stRef:instanceID="xmp.iid:26ebb4c7-3ea9-6e4e-a2e0-5f8686aab1ea" stRef:documentID="xmp.did:a90bc5b9-7cea-af49-a9ed-f1346aff474b" stRef:originalDocumentID="xmp.did:a90bc5b9-7cea-af49-a9ed-f1346aff474b"/> </rdf:Description> </rdf:RDF> </x:xmpmeta> <?xpacket end="r"?>%A2  }IDAT8mMoQ;OۙW-1i؈Z N]$+BD|B/kDRIO
թ>>/Z<:y;2t%{*9ڤ#OIiŪGcUg>['m{IL3+6CNws`!8'Kq\ڬbT[fWݩ:Q^)!AЂת&eض{L0[̗l+QBC0V̏ 
u'_LQJO{Mh&&̾шP/1Q( }XkiooݻIgfS_?5Tk	,YMU4%K2W+\z8@[>U9'ׂ@o嘤c#zLQ+_ޣT?SUsoyߦpaaÏvqIx( .IB>tFpn-lnM<ƛV8a a Q%mǵc-@M 5&`\dgZiMG]s%('[ ,-\q%#kWu(
T#:Yde)xv#bѯ:gPT`cVcL#>jV    IENDB`


icons/icon128.png:
--------------------------------------------------
PNG

   
IHDR         >a   	pHYs  .#  .#x?v  
iTXtXML:com.adobe.xmp     <?xpacket begin="﻿" id="W5M0MpCehiHzreSzNTczkc9d"?> <x:xmpmeta xmlns:x="adobe:ns:meta/" x:xmptk="Adobe XMP Core 6.0-c003 116.ddc7bc4, 2021/08/17-13:18:37        "> <rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"> <rdf:Description rdf:about="" xmlns:xmp="http://ns.adobe.com/xap/1.0/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:xmpMM="http://ns.adobe.com/xap/1.0/mm/" xmlns:stEvt="http://ns.adobe.com/xap/1.0/sType/ResourceEvent#" xmlns:stRef="http://ns.adobe.com/xap/1.0/sType/ResourceRef#" xmlns:photoshop="http://ns.adobe.com/photoshop/1.0/" xmlns:tiff="http://ns.adobe.com/tiff/1.0/" xmlns:exif="http://ns.adobe.com/exif/1.0/" xmp:CreatorTool="Adobe Photoshop 21.2 (Windows)" xmp:CreateDate="2025-05-27T20:00:26+04:00" xmp:MetadataDate="2025-05-29T08:47:51+04:00" xmp:ModifyDate="2025-05-29T08:47:51+04:00" dc:format="image/png" xmpMM:InstanceID="xmp.iid:5197223e-f544-dc48-ab82-a8d81efe79f7" xmpMM:DocumentID="adobe:docid:photoshop:264f81c3-0cb1-594d-80c9-c677b4505719" xmpMM:OriginalDocumentID="xmp.did:a90bc5b9-7cea-af49-a9ed-f1346aff474b" photoshop:ColorMode="3" photoshop:ICCProfile="sRGB IEC61966-2.1" tiff:Orientation="1" tiff:XResolution="3000000/10000" tiff:YResolution="3000000/10000" tiff:ResolutionUnit="2" exif:ColorSpace="65535" exif:PixelXDimension="231" exif:PixelYDimension="231"> <xmpMM:History> <rdf:Seq> <rdf:li stEvt:action="created" stEvt:instanceID="xmp.iid:a90bc5b9-7cea-af49-a9ed-f1346aff474b" stEvt:when="2025-05-27T20:00:26+04:00" stEvt:softwareAgent="Adobe Photoshop 21.2 (Windows)"/> <rdf:li stEvt:action="saved" stEvt:instanceID="xmp.iid:ccc09a5f-f29a-3744-a216-64cd058a4f66" stEvt:when="2025-05-29T08:47:26+04:00" stEvt:softwareAgent="Adobe Photoshop 21.2 (Windows)" stEvt:changed="/"/> <rdf:li stEvt:action="saved" stEvt:instanceID="xmp.iid:5584399b-1f72-904e-9b2e-9cf512790cf2" stEvt:when="2025-05-29T08:47:51+04:00" stEvt:softwareAgent="Adobe Photoshop 21.2 (Windows)" stEvt:changed="/"/> <rdf:li stEvt:action="converted" stEvt:parameters="from application/vnd.adobe.photoshop to image/png"/> <rdf:li stEvt:action="derived" stEvt:parameters="converted from application/vnd.adobe.photoshop to image/png"/> <rdf:li stEvt:action="saved" stEvt:instanceID="xmp.iid:5197223e-f544-dc48-ab82-a8d81efe79f7" stEvt:when="2025-05-29T08:47:51+04:00" stEvt:softwareAgent="Adobe Photoshop 21.2 (Windows)" stEvt:changed="/"/> </rdf:Seq> </xmpMM:History> <xmpMM:DerivedFrom stRef:instanceID="xmp.iid:5584399b-1f72-904e-9b2e-9cf512790cf2" stRef:documentID="xmp.did:a90bc5b9-7cea-af49-a9ed-f1346aff474b" stRef:originalDocumentID="xmp.did:a90bc5b9-7cea-af49-a9ed-f1346aff474b"/> </rdf:Description> </rdf:RDF> </x:xmpmeta> <?xpacket end="r"?>㱜  IDATxy\U?-$M:i4IH::tX(l	rDuaPT@1&^I;]NUv[՝NIWwI}ιY_{}.%9u1 .n^'|w$O $108qӷ |M8q
K#IWXz!Rxh!Xe.@6BfВP(Ȉ^w3}
B.4
](;<)}ϗtCQR7+H2h,>iu#@#$}
OE
i&	-Lǐ!+&Iha-&} GPDq
Q
-A"=|y J 4)UrN輿cA٤AN1H	Rn4!
  rI4o0A*5I;I !H@])Z{Z2H#44y}\WgW2xF

_%$N '8&<D A 
!&/s<ϻfB0L՗C	iaeZ p0Ф#/U!CJ$W	''tvVR	Թ}B78Ly
2Ix	?CKj9v(KV䊢#5<Uu2ZúF
t:xYuRb$h"e.w}tZG}?R.RWB(*xBǑA)YmVΕUxË)Fnt]POrBu\sţҕv'[:lBWuuS_ <g`#j
V\cӳm_md
P@"py	?]z!u<)p(p$z+H^^;FovDPȠ`1p|-ֿ5a]54K]u+"
q^  &r5ОA:ؘR'/W
lL:Z\7$0U 0w65h'Won#SG:mXmƾՠEw6"AHnrc"t[j*|>UR`1~J#Α{.sZd/:zd1P)IT?^C*S#	i㕐3AC-W뚊Gjh`YȽQNNE3o$1pjcťAOO
tֺޗa/!Rʋݸ<aW&qJ3EJHJӯXL<Zn9h, AB,F44lC/F%rCȢwIS/v67Qn+nd\/v&A6[	 )
EUGVv~6q@jяԋC HJD^i]kNYǑ_3XiD?j	 mY8_$NغL<Y!`1z|Hxhқy
 w
C7|*}xYn+n-_7ѐ :Ï	܏Zn<D`_sbO$sO $Zf%PL$VT*.;?R#d}i'NʌA̠ 5hˡ-1XtJ
8о'LtSN̗<Jh僌qCGG;`0;WUfV躎ytlT>ʀzCvww388H(,?B!bS?zCt_NLbY
@;^})uflH)	DQۏ%af+	@h`o31\q䯇&[iڊG01\A2[מ()!X
WKf:x<N Ue2CJI8&Df>p+0~YͶJ	NgwDd ri8޽{O|p˳;0q}KZ NŶ@=D߿ ڷWnW~<V!- <hj#+ggk믿0K?::JGG?` Pi¤ K= Z􌌌M(T!KM4{?78+TԁTA <AFΡ25qLs~;X^:	z9!х t~+q^<1MD"1φWb+$cӋxn5COO<H~e$3ҳ	'BZ BL
~79hiiAJQ,)%Pa76~PvX!- #<U9^]]]nahy?`t_305,X]`e%okkcbb %gn߱Bu}PaV<U/	ܐmZ[[,w7=$}O&"ء2lCU0 $x荍
\ջK_lw`޽xW@:dٯaxߕS A{fhHŅVKRcx*^ M4vbX9 <p*i"6#"0vދ~qhmmEu($N㴵"Q>(@eT.rkNeiF29۬yl vh
V-@eT``TjE%6~ -!kbb(/9h4Za ,l11d5Q{:0	9A{{;욂th+s/	}?+T@҂ad@5(,5Zo;z{{#r0hiiqr뚑4 :7&8Ԑq(&0u6tn8b1NVu}5@0\&\:::FD@
طou}ƶ rJ ܬ<NPJI  f6;7֤|5 H67ia̼/ߤ|`O4Ԙ{uݓ. L<xu}$ԬL7		X7x'0u;)P4Wgg'h2Btvv2>>^hSH<8*Quiii9)ҁ6g:)m	]/ xjD#}y澕cH L."+R[s[?"nvHyb_%xjo?\O擝OSJ
 {`,O0])u/7%&
QR2~^\~y#brupqShd?{g(mSu5l
8",S4df!~<d
;*lرs$j"oޘ'0%2C[,Vt:F~t#7}6x 
hV/_5[jtغygb]L	!]׼=UU,C ,JkHDOS8P@CN!bull(Jm=;Cq酒 5k?
Xj׫u-AO3M 6{;f[7mcLSa1
|,Q㹼Qlm1&6sf^:NoyK*6mW6Z1p*5wcM5v:]4Tww!bt|>mbJ&
j׳c̈́0
k$7І/%s	0b`
d'xl&(  <|+^rDrLpR C@`V}4g@hGVW]%ä`0CG{x`4'Z@x0Q J@
wB@]cD"5pfOז  9Dn5MOn=[n
z'y)(P6!|fɲ?]+ Q_c6dE=|<ɑ^Λ9Y@غi+4X7]Į񃥒;Q>XYcK:"~e恦k8+Yx#lpƭ;ّ?8 ~C3μW,Dvs:P{#ߌJHx6d!$4}Zio11G-KI֖at?ڐqI	wn
%'J~iә_,c#Hf[6
gk]+iP>=ME{EwY"Z׼dLxӣ8^$
(%m'Bc[y9fu2	ϼf_Oq	 ٶ&Drzw4݃L$=Ѱ~RAp)';H ))~_q~4g?qDU.u.Pɦn?'~Y3'7z6 PuedP>\m6zT2^"
3n`u⋕۰7^^"
zf#`|)w/Ri'R҆!Q(u}aweWw?jpi!4=_ՐLB_@c[z&O4}^w"P>;!RXr
<\PFt*(͌dLkRhK`{6M5_N?z;*Z%_L_pz2L  gܽ,LLwj]_-hJ&&=(͚L3E@3Cn7rZB94hDRY7Wfs	q_B%JH#+qgsUӍ`*Y>i`zǹR3 ʹ>^^a~|Š/ ;wù'3Ne@,{/BrOVFﭺޥ,u}G
\:g&uk*y'
aEԝ5oΟcjZY	 Wv_g+gn`Z=Ru絨7WY8O/YοuE;gt<DP\Κϐٔ=QuB۾|2S܄Y#/)偣zԽ*~.FstS1Խ|8'eN`_8#Vf\<uJ!I]{\ [=[w:)_V7PW91cA?b{1
L?	5v>ԵnU S*p~ 0zFd--3B]٨k-"4E=wQ3u-QVTr tBkQs
/5sqkQr<@7ל/	\ gEUH(̒bL(!\dS/**Lr %U r曁@5ˁ,9z^	gR8aNe`%P";Ud0S_DPv ,9qe*t;    IENDB`


actions/loadallevents_error.js:
--------------------------------------------------
// actions/loadallevents_error.js

(function () {
    console.log("Скрипт 'Поиск ошибок: Все события' запущен");

    function getRandomPause(count) {
        if (count >= 1 && count <= 50) {
            return { value: Math.random() * (300 - 100) + 100 };
        } else if (count >= 51 && count <= 200) {
            return { value: Math.random() * (500 - 300) + 300 };
        } else if (count >= 201 && count <= 500) {
            return { value: Math.random() * (700 - 500) + 500 };
        } else if (count >= 501 && count <= 1000) {
            return { value: Math.random() * (1000 - 700) + 700 };
        } else if (count >= 1001 && count <= 2000) {
            return { value: Math.random() * (2000 - 1000) + 1000 };
        } else if (count > 2000) {
            return { value: Math.random() * (4000 - 2000) + 2000 };
        }
        return { value: 300 };
    }

    function loadAllEvents() {
        const iframe = document.querySelector('iframe.iframe-integration__iframe');
        if (!iframe) {
            console.error('Iframe не найден. Прекращаем выполнение.');
            proceedToNextStep();
            return;
        }

        const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
        const elements = Array.from(iframeDoc.querySelectorAll('.link__inner'));

        const filteredElements = elements.filter(el => {
            const text = el.innerText.trim();
            return /Все \d+( (событи[яй]|событие))?/.test(text);
        });

        const count = filteredElements.length;
        console.log(`Найдено ${count} элементов "Все события"`);

        if (count === 0) {
            console.log('Нет элементов "Все события" — пропускаем клики.');
            proceedToNextStep();
            return;
        }

        // === Старт прогресса с динамическим текстом ===
        if (window.sfuaErrorProgress) {
            window.sfuaErrorProgress.setStep(2, `Загружаю события: 0 из ${count}`);
        }

        const startTime = Date.now();

        function clickWithPause(index) {
            if (index < filteredElements.length) {
                const el = filteredElements[index];
                const text = el.innerText.trim();
                el.click();

                const currentPause = getRandomPause(count);
                const pauseSec = (currentPause.value / 1000).toFixed(3);
                console.log(`Клик: ${text} | Пауза: ${pauseSec} сек`);

                // === Обновляем прогресс ===
                if (window.sfuaErrorProgress) {
                    window.sfuaErrorProgress.setStep(2, `Загружаю события: ${index + 1} из ${count}`);
                }

                setTimeout(() => clickWithPause(index + 1), currentPause.value);
            } else {
                const endTime = Date.now();
                const timeSpent = (endTime - startTime) / 1000;
                console.log(`✅ Все клики по "Все события" выполнены. Время: ${timeSpent.toFixed(2)} сек`);

                // === Переход к поиску ошибок ===
                if (window.sfuaErrorProgress) {
                    window.sfuaErrorProgress.setStep(3, "Ищу ошибки");
                }

                proceedToNextStep();
            }
        }

        clickWithPause(0);
    }

    function proceedToNextStep() {
        console.log('Ожидание 3 секунды перед переходом к founderror.js...');
        setTimeout(() => {
            chrome.runtime.sendMessage({ action: "executeFoundError" });
        }, 3000);
    }

    loadAllEvents();
})();


actions/found_error.js:
--------------------------------------------------
// actions/found_error.js

(function () {
    console.log("Скрипт 'Поиск ошибок: Ищу ошибки' запущен");

    const iframe = document.querySelector('iframe.iframe-integration__iframe');
    if (!iframe) {
        console.error("❌ iframe не найден");
        return;
    }

    let iframeDoc;
    try {
        iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
    } catch (e) {
        console.error("❌ Нет доступа к iframe:", e);
        return;
    }

    if (!iframeDoc) {
        console.error("❌ iframeDoc пуст");
        return;
    }

    // === Находим ВСЕ элементы с красной полосой через ::after ===
    const allDescriptionElements = Array.from(iframeDoc.querySelectorAll(
        '.profile-session__event-description'
    ));

    const errorElements = allDescriptionElements.filter(el => {
        const afterStyle = getComputedStyle(el, '::after');
        const borderColor = afterStyle.borderTopColor ||
                           afterStyle.borderRightColor ||
                           afterStyle.borderBottomColor ||
                           afterStyle.borderLeftColor;
        return borderColor === 'rgb(255, 68, 62)' || borderColor === '#ff443e';
    });

    console.log(`✅ Найдено ${errorElements.length} ошибок (включая Крэш)`);

    if (window.sfuaErrorProgress) {
        window.sfuaErrorProgress.setStep(3, `Ищу ошибки: 0 из ${errorElements.length}`);
    }

    if (errorElements.length === 0) {
        if (window.sfuaErrorProgress && typeof window.sfuaErrorProgress.searchComplete === 'function') {
            window.sfuaErrorProgress.searchComplete();
        }
        return;
    }

    let crashCount = 0;

    for (let i = 0; i < errorElements.length; i++) {
        const el = errorElements[i];
        const eventElement = el.closest('.profile-session__event');

        if (!eventElement) continue;

        const errorId = `error_found_${Date.now()}_${i}`;
        eventElement.id = errorId;

        const nameEl = eventElement.querySelector('.profile-session__event-name');
        const nameText = nameEl?.textContent.trim() || 'ошибка';

        // Проверяем, является ли это "Крэш"
        const isCrash = el.classList.contains('profile-session__event-description_type_crash') ||
                       nameText === 'Крэш';

        if (isCrash) crashCount++;

        const sessionParent = eventElement.closest('.profile-session_js_inited');
        const dateEl = sessionParent?.querySelector('.profile-session__date');
        const fullDateText = dateEl?.textContent.trim() || 'дата не найдена';
        const shortDateText = fullDateText.split(' в ')[0].trim();

        const timeEl = eventElement.querySelector('.profile-session__event-time');
        const timeText = timeEl?.textContent.trim() || 'время не найдено';

        // === Добавляем результат сразу ===
        if (window.sfuaErrorProgress) {
            window.sfuaErrorProgress.addResult({
                id: errorId,
                shortText: `${shortDateText} в ${timeText}`,
                fullText: nameText,
                isCrash: isCrash
            });
        }

        // === Обновляем прогресс ===
        if (window.sfuaErrorProgress) {
            window.sfuaErrorProgress.setStep(3, `Ищу ошибки: ${i + 1} из ${errorElements.length}`);
        }
    }

    // === Вызываем завершение ===
    if (window.sfuaErrorProgress && typeof window.sfuaErrorProgress.searchComplete === 'function') {
        window.sfuaErrorProgress.searchComplete(errorElements.length, crashCount);
    }
})();


actions/showmoresession_error.js:
--------------------------------------------------
// actions/showmoresession_error.js

(function () {
    console.log("Скрипт 'Поиск ошибок: Показать больше сессий' запущен");

    let clickCount = 0;
    const maxClicksBeforeDelay = 10;
    const shortDelay = 3000;
    const longDelay = 5000;

    function clickShowMoreButton() {
        const iframe = document.querySelector('iframe.iframe-integration__iframe');
        if (!iframe) {
            console.warn("Iframe не найден. Повтор через 2 сек.");
            setTimeout(clickShowMoreButton, 2000);
            return;
        }

        let iframeDoc;
        try {
            iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
        } catch (e) {
            console.error("Нет доступа к iframe (CSP/Sandbox):", e);
            setTimeout(clickShowMoreButton, 3000);
            return;
        }

        if (!iframeDoc) {
            console.warn("Не удалось получить document iframe");
            setTimeout(clickShowMoreButton, 3000);
            return;
        }

        const button = iframeDoc.querySelector('.profile-sessions-history__show-more-sessions-button');

        if (button && isElementVisible(button)) {
            console.log(`Кликаем на 'Показать больше сессий' (клик #${++clickCount})`);
            const clickEvent = new MouseEvent('click', {
                bubbles: true,
                cancelable: true,
                view: window
            });
            button.dispatchEvent(clickEvent);

            const delay = clickCount >= maxClicksBeforeDelay ? longDelay : shortDelay;
            setTimeout(clickShowMoreButton, delay);
        } else {
            console.log("Кнопка больше не найдена. Переходим к loadallevents_error.js");

            // Обновляем прогресс
            if (window.sfuaErrorProgress) {
                window.sfuaErrorProgress.setStep(2, "Загружаю события");
            }

            // Запускаем следующий скрипт
            chrome.runtime.sendMessage({ action: "executeLoadAllEventsError" });
        }
    }

    function isElementVisible(element) {
        return element &&
               element.offsetWidth > 0 &&
               element.offsetHeight > 0 &&
               getComputedStyle(element).visibility !== 'hidden' &&
               getComputedStyle(element).display !== 'none';
    }

    // Запускаем
    clickShowMoreButton();
})();


actions/clickpluselements.js:
--------------------------------------------------
// actions/clickpluselements.js

(async function () {
    console.log("Скрипт 'Загрузить дополнительные события' запущен");

    const { eventType } = await chrome.runtime.sendMessage({ action: "getSearchParams" });

    const eventMapping = {
        0: "tap", 1: "open_screen", 2: "condition", 3: "event",
        4: "authorization", 5: "tabbar", 6: "deeplink", 7: "tech",
        8: "error", 9: "open_error", 10: "open_error_screen",
        11: "errorMetric", 12: "offline_tap"
    };

    const selectedEvent = eventMapping[eventType] || "tap";

    function getRandomPause(count) {
        let pause;
        if (count >= 1 && count <= 50) pause = Math.random() * (300 - 100) + 100;
        else if (count >= 51 && count <= 200) pause = Math.random() * (500 - 300) + 300;
        else if (count >= 201 && count <= 500) pause = Math.random() * (700 - 500) + 500;
        else if (count >= 501 && count <= 1000) pause = Math.random() * (1000 - 700) + 700;
        else if (count >= 1001 && count <= 2000) pause = Math.random() * (2000 - 1000) + 1000;
        else if (count > 2000) pause = Math.random() * (4000 - 2000) + 2000;
        else pause = 300;
        return { value: pause };
    }

    function getRelevantPlusElements(selectedEvent) {
        const iframe = document.querySelector('iframe.iframe-integration__iframe');
        if (!iframe) return [];
        const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
        const eventNameElements = Array.from(
            iframeDoc.querySelectorAll('.profile-session__event-name-link .link__inner')
        ).filter(el => el.textContent.trim().toLowerCase() === selectedEvent.toLowerCase());

        const plusElements = [];
        eventNameElements.forEach(eventNameEl => {
            const eventContainer = eventNameEl.closest('.profile-session__event-description_type_client');
            if (eventContainer) {
                const plusEl = eventContainer.querySelector('.profile-session__expander-link .link__inner:not(.clicked)');
                if (plusEl && plusEl.textContent.trim().startsWith('+')) {
                    plusElements.push({ element: plusEl, parent: eventContainer });
                }
            }
        });
        return plusElements;
    }

    async function clickRelevantElements() {
        console.log(`Выбранное событие: ${selectedEvent}`);
        let waveNum = 1;

        while (true) {
            const elements = getRelevantPlusElements(selectedEvent);
            const count = elements.length;

            if (count === 0) break;

            const updateProgress = window.sfuaProgress?.startProgress
                ? window.sfuaProgress.startProgress(`Загружаю дополнительные события (волна ${waveNum})`, count)
                : null;

            for (let i = 0; i < count; i++) {
                const { element, parent } = elements[i];
                try {
                    element.classList.add('clicked');
                    parent.classList.add(`wave_${waveNum}`);
                    element.click();

                    if (updateProgress && typeof window.sfuaProgress?.updateProgress === 'function') {
                        window.sfuaProgress.updateProgress(() => {
                            updateProgress(i + 1);
                        });
                    }

                    const currentPause = getRandomPause(count);
                    if (i < count - 1) {
                        await new Promise(resolve => setTimeout(resolve, currentPause.value));
                    }
                } catch (error) {
                    console.error('Ошибка при клике:', error);
                }
            }

            await new Promise(resolve => setTimeout(resolve, 3000));
            waveNum++;
        }

        // ✅ Убираем setStep(4, ...) — пусть clickeventelements сам управляет прогрессом
        console.log('Запускаем clickeventelements.js через 1 секунду');
        setTimeout(() => {
            chrome.runtime.sendMessage({ action: "executeClickEventElements" });
        }, 1000);
    }

    await clickRelevantElements();
})();


actions/updateprogress.js:
--------------------------------------------------
// Добавляем стили из отдельного файла
const link = document.createElement('link');
link.rel = 'stylesheet';
link.href = chrome.runtime.getURL('styles.css');
document.head.appendChild(link);

function hideElements() {
    const elementsToHide = [
        'updateId_container',
        'inputEvent_container',
        'input-details__key',
        'input-details__value',
        'start_search'
    ];

    elementsToHide.forEach(id => {
        const element = document.getElementById(id);
        if (element) {
            element.style.display = 'none';
        }
    });
}

function createProgressInterface() {
    const infoContainer = document.getElementById('infoContainer');
    if (!infoContainer) {
        console.error('Контейнер infoContainer не найден');
        return null;
    }

    const progressContainer = document.createElement('div');
    progressContainer.className = 'progress-container';

    for (let i = 0; i < 5; i++) {
        const circle = document.createElement('div');
        circle.className = `progress-circle progress-circle-${i+1}`;
        progressContainer.appendChild(circle);
    }

    infoContainer.appendChild(progressContainer);

    const statusText = document.createElement('div');
    statusText.className = 'progress-status-text';
    statusText.textContent = 'Загружаю сессии';
    infoContainer.appendChild(statusText);

    progressContainer.style.display = 'none';
    statusText.style.display = 'none';

    return { progressContainer, statusText };
}

function updateProgress(step, progressContainer, statusText) {
    if (!progressContainer || !statusText) return;

    const circles = progressContainer.querySelectorAll('.progress-circle');

    circles.forEach((circle, index) => {
        circle.style.width = '20px';
        circle.style.height = '20px';
        
        if (!circle.classList.contains('active')) {
            circle.style.backgroundColor = '';
        }
    });

    const steps = [
        { 
            text: 'Загружаю сессии',
            activeCircle: 0,
            nextCircleSize: 0
        },
        {
            text: 'Загружаю все события',
            activeCircle: 0,
            nextCircleSize: 1
        },
        {
            text: 'Загружаю дополнительные события',
            activeCircle: 1,
            nextCircleSize: 2
        },
        {
            text: 'Кликаю по выбранному событию',
            activeCircle: 2,
            nextCircleSize: 3
        },
        {
            text: 'Ищу запрошенные события',
            activeCircle: 3,
            nextCircleSize: 4
        },
        {
            text: 'Поиск завершен',
            activeCircle: -1
        }
    ];

    if (step >= 0 && step < steps.length) {
        const currentStep = steps[step];
        statusText.textContent = currentStep.text;

        if (currentStep.activeCircle >= 0) {
            if (currentStep.activeCircle === -1) {
                circles.forEach(circle => {
                    circle.classList.add('active');
                });
            } else {
                circles[currentStep.activeCircle].classList.add('active');
            }
        }

        if (currentStep.nextCircleSize !== undefined && step < steps.length - 1) {
            const nextCircle = circles[step + 1];
            if (nextCircle) {
                nextCircle.style.width = '10px';
                nextCircle.style.height = '10px';
            }
        }
    }
}

function initProgress() {
    const iframe = document.querySelector('iframe.iframe-integration__iframe');
    if (!iframe) {
        console.error('Iframe не найден');
        return;
    }

    const iframeDocument = iframe.contentDocument || iframe.contentWindow.document;
    if (!iframeDocument) {
        console.error('Не удалось получить доступ к документу iframe');
        return;
    }

    const showMoreButton = iframeDocument.querySelector('.profile-sessions-history__show-more-sessions-button');
    
    if (showMoreButton) {
        showMoreButton.addEventListener('click', () => {
            hideElements();
            const progress = createProgressInterface();
            if (progress) {
                const { progressContainer, statusText } = progress;
                progressContainer.style.display = 'flex';
                statusText.style.display = 'block';
                updateProgress(0, progressContainer, statusText);
                
                // Пример автоматического обновления прогресса (можно заменить на реальные события)
                let currentStep = 0;
                const interval = setInterval(() => {
                    currentStep++;
                    if (currentStep <= 5) {
                        updateProgress(currentStep, progressContainer, statusText);
                    } else {
                        clearInterval(interval);
                    }
                }, 2000);
            }
        });
    } else {
        console.log('Кнопка "Показать больше сессий" не найдена');
    }
}

// Запускаем инициализацию после полной загрузки страницы
if (document.readyState === 'complete') {
    initProgress();
} else {
    document.addEventListener('DOMContentLoaded', initProgress);
}


actions/showmoresession.js:
--------------------------------------------------
(function () {
    console.log("Скрипт 'Показать больше сессий' запущен");

    let clickCount = 0;
    const maxClicksBeforeDelay = 10;
    const shortDelay = 3000;
    const longDelay = 5000;

    function clickShowMoreButton() {
        const iframe = document.querySelector('iframe.iframe-integration__iframe');
        if (!iframe) {
            console.warn("Iframe не найден. Повтор через 2 сек.");
            setTimeout(clickShowMoreButton, 2000);
            return;
        }

        let iframeDoc;
        try {
            iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
        } catch (e) {
            console.error("Нет доступа к iframe (CSP/Sandbox):", e);
            setTimeout(clickShowMoreButton, 3000);
            return;
        }

        if (!iframeDoc) {
            console.warn("Не удалось получить document iframe");
            setTimeout(clickShowMoreButton, 3000);
            return;
        }

        const button = iframeDoc.querySelector('.profile-sessions-history__show-more-sessions-button');

        if (button && isElementVisible(button)) {
            console.log(`Кликаем на 'Показать больше сессий' (клик #${++clickCount})`);
            const clickEvent = new MouseEvent('click', {
                bubbles: true,
                cancelable: true,
                view: window
            });
            button.dispatchEvent(clickEvent);

            const delay = clickCount >= maxClicksBeforeDelay ? longDelay : shortDelay;
            setTimeout(clickShowMoreButton, delay);
        } else {
            console.log("Кнопка больше не найдена или скрыта. Завершаем. \nЗапускаем loadallevents.js");

            // === Обновляем прогресс-бар ===
            if (typeof window.sfuaProgress !== 'undefined') {
                window.sfuaProgress.setStep(2, "Загружаю события");
            }

            // === Запускаем следующий скрипт ===
            chrome.runtime.sendMessage({ action: "executeLoadAllEvents" });
        }
    }

    function isElementVisible(element) {
        return element &&
               element.offsetWidth > 0 &&
               element.offsetHeight > 0 &&
               getComputedStyle(element).visibility !== 'hidden' &&
               getComputedStyle(element).display !== 'none';
    }

    // Запускаем
    clickShowMoreButton();
})();


actions/loadallevents.js:
--------------------------------------------------
// actions/loadallevents.js

(async function () {
    console.log("Скрипт 'Все события' запущен");

    function getRandomPause(count) {
        let pause;
        if (count >= 1 && count <= 50) {
            pause = Math.random() * (300 - 100) + 100;
        } else if (count >= 51 && count <= 200) {
            pause = Math.random() * (500 - 300) + 300;
        } else if (count >= 201 && count <= 500) {
            pause = Math.random() * (700 - 500) + 500;
        } else if (count >= 501 && count <= 1000) {
            pause = Math.random() * (1000 - 700) + 700;
        } else if (count >= 1001 && count <= 2000) {
            pause = Math.random() * (2000 - 1000) + 1000;
        } else if (count > 2000) {
            pause = Math.random() * (4000 - 2000) + 2000;
        } else {
            pause = 300;
        }
        return { value: Math.max(100, pause) };
    }

    function loadAllEvents() {
        const iframe = document.querySelector('iframe.iframe-integration__iframe');
        if (!iframe) {
            console.error('[loadallevents] Iframe не найден');
            proceedToNextStep();
            return;
        }

        let iframeDoc;
        try {
            iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
        } catch (e) {
            console.error('[loadallevents] Ошибка доступа к iframe:', e);
            proceedToNextStep();
            return;
        }

        if (!iframeDoc) {
            console.error('[loadallevents] iframeDoc пустой');
            proceedToNextStep();
            return;
        }

        // Ждём, пока загрузится хотя бы один элемент
        setTimeout(() => {
            const elements = Array.from(iframeDoc.querySelectorAll('.link__inner'));
            const filteredElements = elements.filter(el => {
                const text = el.innerText?.trim() || '';
                return /Все \d+(\s(событи[яй]|событие))?/.test(text);
            });

            const count = filteredElements.length;
            console.log(`[loadallevents] Найдено "Все N событий": ${count}`);

            if (count === 0) {
                console.log('[loadallevents] Нет элементов для клика — переходим дальше');
                proceedToNextStep();
                return;
            }

            // === Обновляем прогресс ===
            if (typeof window.sfuaProgress !== 'undefined') {
                window.sfuaProgress.setStep(2, "Загружаю события");

                // Добавляем "N из X" только после того, как count известен
                const updateProgress = window.sfuaProgress.startProgress("Загружаю события", count);

                let index = 0;
                const startTime = Date.now();

                function clickNext() {
                    if (index < filteredElements.length) {
                        const el = filteredElements[index];
                        const text = el.innerText?.trim() || 'неизвестно';

                        try {
                            el.click();
                            console.log(`[loadallevents] Клик ${index + 1}/${count}: ${text}`);

                            // Обновляем прогресс
                            window.sfuaProgress.updateProgress(() => {
                                updateProgress(index + 1);
                            });

                            index++;
                            const pause = getRandomPause(count).value;
                            setTimeout(clickNext, pause);
                        } catch (err) {
                            console.error('[loadallevents] Ошибка клика:', err);
                            index++;
                            setTimeout(clickNext, 500);
                        }
                    } else {
                        const duration = ((Date.now() - startTime) / 1000).toFixed(1);
                        console.log(`[loadallevents] ✅ Все клики выполнены за ${duration} сек`);
                        window.sfuaProgress.setStep(3, "Загружаю дополнительные события");
                        proceedToNextStep();
                    }
                }

                // Запускаем цикл
                clickNext();
            } else {
                console.warn('[loadallevents] window.sfuaProgress не определён');
                proceedToNextStep();
            }
        }, 1000); // Даём время на рендер
    }

    function proceedToNextStep() {
        console.log('[loadallevents] Переход к следующему шагу...');
        setTimeout(() => {
            chrome.runtime.sendMessage({ action: "executeClickPlusElement" });
        }, 3000);
    }

    // Запускаем
    loadAllEvents();
})();


actions/clickeventelements.js:
--------------------------------------------------
// actions/clickeventelements.js

(async function () {
    console.log("Скрипт 'Клик по событиям' запущен");

    let eventType, key, value;

    try {
        const paramsResponse = await chrome.runtime.sendMessage({ action: "getSearchParams" });
        eventType = paramsResponse.eventType ?? 0;
        key = paramsResponse.key ?? '%';
        value = paramsResponse.value ?? 'обновить данные';
    } catch (error) {
        console.error("Ошибка при получении параметров поиска:", error);
        window.sfuaProgress?.searchComplete(false, 'Не удалось получить параметры поиска');
        return;
    }

    const eventMapping = {
        0: "tap", 1: "open_screen", 2: "condition", 3: "event",
        4: "authorization", 5: "tabbar", 6: "Deeplink", 7: "tech",
        8: "error", 9: "open_error", 10: "open_error_screen",
        11: "errorMetric", 12: "offline_tap"
    };

    const selectedEvent = eventMapping[eventType] || "tap";

    if (window.__SFUA_CLICK_EVENTS_RUNNING__) return;
    window.__SFUA_CLICK_EVENTS_RUNNING__ = true;

    function convertToRegex(str) {
        const trimmed = str.trim();
        if (trimmed === '%') return /.+/;
        const escaped = trimmed.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        return new RegExp(escaped.replace(/%/g, '.*'), 'i');
    }

    const regexKey = convertToRegex(key);
    const regexValue = convertToRegex(value);

    function delay(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    function getRandomPause(count) {
        const map = [
            [1, 50, 100, 300],
            [51, 200, 300, 500],
            [201, 500, 500, 700],
            [501, 1000, 700, 1000],
            [1001, 2000, 1000, 2000],
            [2001, Infinity, 2000, 4000]
        ];
        for (const [min, max, minMs, maxMs] of map) {
            if (count >= min && count <= max) {
                return Math.random() * (maxMs - minMs) + minMs;
            }
        }
        return 300;
    }

    function simulateClickWithCheck(element) {
        if (!element || element.classList.contains('span_checked')) return;
        element.click();
        element.classList.add('span_checked');
        element.dispatchEvent(new CustomEvent('sfua:spanToggled', {
            bubbles: true,
            detail: { checked: true }
        }));
    }

    async function clickAndSearch() {
        const iframe = document.querySelector('.iframe-integration__iframe');
        if (!iframe) {
            window.sfuaProgress?.searchComplete(false, 'iframe не найден');
            return;
        }

        let iframeDoc;
        try {
            iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
        } catch (e) {
            window.sfuaProgress?.searchComplete(false, 'Нет доступа к iframe');
            return;
        }

        if (!iframeDoc) {
            window.sfuaProgress?.searchComplete(false, 'iframe не загружен');
            return;
        }

        iframeDoc.querySelectorAll('.this_one_matches').forEach(el => {
            el.style.border = '';
            el.classList.remove('this_one_matches');
        });

        const allEventSpans = [...iframeDoc.querySelectorAll('span.link__inner')]
            .filter(span => {
                const text = span.textContent.trim();
                return text === selectedEvent && !span.classList.contains('span_checked');
            });

        const total = allEventSpans.length;
        console.log(`Найдено "${selectedEvent}": ${total}`);

        if (total === 0) {
            window.sfuaProgress?.searchComplete(true, 'Совпадений не найдено');
            return;
        }

        // ✅ Только здесь — когда total известен — обновляем прогресс
        if (typeof window.sfuaProgress !== 'undefined') {
            window.sfuaProgress.setStep(4, "Кликаю по событиям и осуществляю поиск");
        }

        const updateProgress = window.sfuaProgress?.startProgress
            ? window.sfuaProgress.startProgress("Кликаю по событиям и осуществляю поиск", total)
            : null;

        let eventCounter = 1;
        let foundAny = false;

        for (let i = 0; i < total; i++) {
            const span = allEventSpans[i];
            simulateClickWithCheck(span);
            await delay(getRandomPause(total));

            const allParams = iframeDoc.querySelectorAll('.event-details__param');
            for (const param of allParams) {
                if (param.classList.contains('check_has_already_been_performed')) continue;

                const keyEl = param.querySelector('.event-details__key');
                const valueEl = param.querySelector('.event-details__value');
                if (!keyEl || !valueEl) {
                    param.classList.add('check_has_already_been_performed');
                    continue;
                }

                const keyText = keyEl.textContent.trim();
                const valueText = valueEl.textContent.trim();

                if (regexKey.test(keyText) && regexValue.test(valueText)) {
                    foundAny = true;
                    const eventParent = param.closest('.profile-session__event');
                    const sessionParent = eventParent?.closest('.profile-session_js_inited');
                    const timeEl = eventParent?.querySelector('.profile-session__event-time');
                    const dateEl = sessionParent?.querySelector('.profile-session__date');

                    const timeText = timeEl?.textContent.trim() || 'время не найдено';
                    const dateText = dateEl?.textContent.trim() || 'дата не найдено';
                    const shortDateText = dateText.split(' ').slice(0, 2).join(' ');

                    const anchorId = `found_event_${Date.now()}_${eventCounter++}`;
                    if (timeEl) timeEl.id = anchorId;

                    const detailsParent = param.closest('.event-details_js_inited');
                    if (detailsParent) {
                        detailsParent.classList.add('this_one_matches');
                        detailsParent.style.border = '2px solid #008D00';
                    }

                    window.sfuaProgress?.addResult({ id: anchorId, shortDateText, timeText });
                }

                param.classList.add('check_has_already_been_performed');
            }

            // ✅ Обновляем прогресс
            if (updateProgress && typeof window.sfuaProgress?.updateProgress === 'function') {
                window.sfuaProgress.updateProgress(() => {
                    updateProgress(i + 1);
                });
            }
        }

        window.sfuaProgress?.searchComplete(true, foundAny ? undefined : 'Совпадений не найдено');
    }

    try {
        await delay(1000);
        await clickAndSearch();
    } catch (err) {
        console.error("Ошибка в clickeventelements:", err);
        window.sfuaProgress?.searchComplete(false, 'Ошибка: ' + err.message);
    } finally {
        delete window.__SFUA_CLICK_EVENTS_RUNNING__;
    }
})();


background/userinfo.js:
--------------------------------------------------
// background/userinfo.js

(function () {
    // Проверяем, не загружен ли уже скрипт
    if (window.sfua_userinfo_loaded) {
        console.log('[SFUA] userinfo.js уже загружен — пропускаем');
        return;
    }
    window.sfua_userinfo_loaded = true;

    // Глобальная переменная для хранения часовых поясов
    let TIMEZONES = null;

    // Загружаем timezones.json
    async function loadTimezones() {
        try {
            const url = chrome.runtime.getURL('data/timezones.json');
            const response = await fetch(url);
            if (!response.ok) throw new Error('Не удалось загрузить timezones.json');
            TIMEZONES = await response.json();
            console.log('[SFUA] Часовые пояса загружены');
        } catch (error) {
            console.error('[SFUA] Ошибка загрузки timezones.json:', error);
            TIMEZONES = {}; // fallback
        }
    }

    // Инициализация
    async function initializeUserInfo() {
        await loadTimezones();

        const iframe = document.querySelector('.iframe-integration__iframe');
        if (!iframe) {
            setTimeout(initializeUserInfo, 500);
            return;
        }

        const iframeDocument = iframe.contentDocument || iframe.contentWindow.document;

        // === Плавное исчезновение аватара ===
        const profileImage = iframeDocument.querySelector('div.page-user-profile__profile-image');
        if (profileImage) {
            profileImage.style.transition = 'transform 0.6s cubic-bezier(0.4, 0, 0.2, 1)';
            void profileImage.offsetWidth;
            profileImage.style.transform = 'scale(0)';
            setTimeout(() => {
                profileImage.style.display = 'none';
            }, 600);
        }

        const profileTableElement = iframeDocument.querySelector('table.profile-info-table__table');
        if (!profileTableElement) {
            setTimeout(initializeUserInfo, 500);
            return;
        }

        // Подключаем стили
        const link = document.createElement('link');
        link.rel = 'stylesheet';
        link.href = chrome.runtime.getURL('background/styles/userinfo.css');
        link.onerror = () => {
            console.error('[SFUA] Не удалось загрузить userinfo.css');
        };
        iframeDocument.head.appendChild(link);

        setTimeout(() => {
            processUserInfo(iframeDocument, profileImage, profileTableElement);
        }, 100);
    }

function processUserInfo(iframeDocument, profileImage, profileTableElement) {
    const headers = iframeDocument.querySelectorAll('th.profile-info-table__row-header');
    const dataCells = iframeDocument.querySelectorAll('td.profile-info-table__row-data-cell');

    console.log('[SFUA] Найдено заголовков:', headers.length);
    console.log('[SFUA] Найдено ячеек данных:', dataCells.length);

    // === Добавляем классы main_userinfo_headerX и main_userinfo_dataX ===
    headers.forEach((header, index) => {
        header.classList.add(`main_userinfo_header${index + 1}`);
        header.style.paddingBottom = '5px';
    });

    // === Храним актуальные данные ===
    const data = {};

    dataCells.forEach((cell, index) => {
        const cellIndex = index + 1;
        cell.classList.add(`main_userinfo_data${cellIndex}`);

        const headerCell = headers[index];
        if (!headerCell) return;

        const headerText = headerCell.textContent.trim();

        let cellText = cell.textContent.trim();

        // === Если это "Версия приложения" — очищаем ===
        if (headerText === "Версия приложения" || (headerText.includes("Версия") && headerText.includes("прилож"))) {
            console.log(`[SFUA] Обнаружена версия: "${cellText}"`);

            // Удаляем всё начиная с первой открывающей скобки
            const openParenIndex = cellText.indexOf('(');
            let cleanedText = cellText;
            if (openParenIndex !== -1) {
                cleanedText = cellText.substring(0, openParenIndex).trim();
            }

            console.log(`[SFUA] Очищено: "${cleanedText}"`);

            if (cleanedText !== cellText) {
                // Принудительно обновляем DOM
                cell.textContent = '';
                setTimeout(() => {
                    cell.textContent = cleanedText;
                    console.log(`✅ Ячейка main_userinfo_data${cellIndex} обновлена`);
                }, 0);

                // 🔥 Сразу обновляем значение в data
                data[cellIndex] = cleanedText;
            } else {
                data[cellIndex] = cellText;
            }
        } else {
            // Обычное значение
            data[cellIndex] = cellText;
        }
    });

    // === Теперь собираем headersData из headers ===
    const headersData = {};
    headers.forEach((header, index) => {
        headersData[index + 1] = header.textContent.trim();
    });

    // === Создаём контейнер с актуальными данными ===
    createUserInfoContainer(iframeDocument, profileImage, profileTableElement, headersData, data);
}

function createUserInfoContainer(iframeDocument, profileImage, profileTableElement, headersData, data) {
    const existingContainer = iframeDocument.querySelector('.userinfo_container');
    if (existingContainer) {
        fadeOut(existingContainer, () => {
            existingContainer.remove();
            if (profileImage) {
                profileImage.style.display = '';
            }
        });
        return;
    }

    // === Кнопка с анимацией текста ===
    const toggleButton = document.createElement('button');
    toggleButton.className = 'toggle-details-button';
    toggleButton.style.overflow = 'hidden';
    toggleButton.style.position = 'relative';
    toggleButton.style.transform = 'scale(0)';
    toggleButton.style.transformOrigin = 'top center';

    const textContainer = document.createElement('div');
    textContainer.style.position = 'absolute';
    textContainer.style.top = '0';
    textContainer.style.left = '0';
    textContainer.style.width = '100%';
    textContainer.style.height = '100%';
    textContainer.style.display = 'flex';
    textContainer.style.flexDirection = 'column';
    textContainer.style.justifyContent = 'center';
    textContainer.style.alignItems = 'center';
    textContainer.style.gap = '0';
    textContainer.style.overflow = 'hidden';

    const oldText = document.createElement('span');
    oldText.textContent = 'Показать подробно';
    oldText.style.position = 'absolute';
    oldText.style.top = '0';
    oldText.style.left = '0';
    oldText.style.width = '100%';
    oldText.style.textAlign = 'center';
    oldText.style.lineHeight = '30px';
    oldText.style.transform = 'translateY(-100%)';
    oldText.style.transition = 'transform 0.3s ease-out';
    oldText.style.display = 'block';

    const newText = document.createElement('span');
    newText.textContent = 'Показать кратко';
    newText.style.position = 'absolute';
    newText.style.top = '0';
    newText.style.left = '0';
    newText.style.width = '100%';
    newText.style.textAlign = 'center';
    newText.style.lineHeight = '30px';
    newText.style.transform = 'translateY(0)';
    newText.style.transition = 'transform 0.3s ease-out';
    newText.style.display = 'block';

    textContainer.appendChild(oldText);
    textContainer.appendChild(newText);
    toggleButton.appendChild(textContainer);

    const container = document.createElement('div');
    container.className = 'userinfo_container';
    container.style.display = 'block';
    container.style.transform = 'scale(0)';
    container.style.transformOrigin = 'top';
    container.style.transition = 'transform 0.3s ease-out';

    // ✅ Передаём актуальные данные
    container.innerHTML = generateInfoHTML(headersData, data);

    profileTableElement.style.transform = 'scale(0)';
    profileTableElement.style.transformOrigin = 'top';
    profileTableElement.style.transition = 'transform 0.3s ease-out';

    const wrapper = document.createElement('div');
    wrapper.style.display = 'flex';
    wrapper.style.flexDirection = 'column';
    wrapper.style.gap = '10px';
    wrapper.appendChild(toggleButton);
    wrapper.appendChild(container);

    if (profileImage) {
        profileImage.parentNode.insertBefore(wrapper, profileImage.nextSibling);
    } else {
        const parent = iframeDocument.querySelector('.page-user-profile__main-info') || iframeDocument.body;
        parent.insertBefore(wrapper, parent.firstChild);
    }

    // === Анимация появления ===
    setTimeout(() => {
        toggleButton.style.transition = 'transform 0.3s ease-out, max-height 0.4s ease';
        toggleButton.style.maxHeight = '40px';
        toggleButton.style.transform = 'scale(1)';
    }, 100);

    // === Загружаем состояние ===
    chrome.storage.local.get(['sfua_userinfo_showCompact'], async (result) => {
        const showCompact = result.sfua_userinfo_showCompact ?? false;

        if (showCompact) {
            container.style.display = 'block';
            profileTableElement.classList.add('hidden');
            container.style.transform = 'scale(1)';
            profileTableElement.style.transform = 'scale(0)';

            newText.style.transform = 'translateY(100%)';
            oldText.style.transform = 'translateY(0)';
        } else {
            container.style.display = 'none';
            profileTableElement.classList.remove('hidden');
            profileTableElement.style.transform = 'scale(1)';
            container.style.transform = 'scale(0)';

            oldText.style.transform = 'translateY(-100%)';
            newText.style.transform = 'translateY(0)';
        }
    });

    // === Переключение ===
    toggleButton.addEventListener('click', () => {
        if (container.style.display === 'none' || container.style.display === '') {
            container.style.display = 'block';
            profileTableElement.classList.add('hidden');
            profileTableElement.style.transform = 'scale(0)';
            setTimeout(() => container.style.transform = 'scale(1)', 10);

            newText.style.transform = 'translateY(100%)';
            oldText.style.transform = 'translateY(0)';

            chrome.storage.local.set({ sfua_userinfo_showCompact: true });
        } else {
            container.style.display = 'none';
            profileTableElement.classList.remove('hidden');
            container.style.transform = 'scale(0)';
            setTimeout(() => profileTableElement.style.transform = 'scale(1)', 10);

            oldText.style.transform = 'translateY(-100%)';
            newText.style.transform = 'translateY(0)';

            chrome.storage.local.set({ sfua_userinfo_showCompact: false });
        }
    });
}

    function generateInfoHTML(headersData, data) {
        let html = '';

        const addInfoRow = (title, value, isWarning = false) => {
            if (value && value !== 'Не найдено') {
                const valueStyle = isWarning ? 'style="color: red;"' : '';
                html += `
                    <div class="userinfo_wrapper">
                        <div class="userinfo_title">${title}:</div>
                        <div class="userinfo_data" ${valueStyle}>${value}</div>
                    </div>
                `;
            }
        };

        // Все строки — как в оригинале
        for (const [index, headerText] of Object.entries(headersData)) {
            const num = parseInt(index);
            if (headerText === "Модель") {
                const deviceValue = `${data[num] || 'Не найдено'} (${data[num-1] || 'Не найдено'})`;
                addInfoRow("Устройство", deviceValue);
                break;
            }
        }

        for (const [index, headerText] of Object.entries(headersData)) {
            const num = parseInt(index);
            if (headerText === "Операционная система") {
                const osValue = `${data[num] || 'Не найдено'} ${data[num+1] || ''}`.trim();
                addInfoRow("ОС", osValue);
                break;
            }
        }

        for (const [index, headerText] of Object.entries(headersData)) {
            const num = parseInt(index);
            if (headerText === "Версия приложения") {
                let version = data[num] || 'Не найдено';
                // Удаляем последнее слово в скобках
                if (version !== 'Не найдено') {
                    version = version.replace(/\s*$$[^)]+$$\s*$/, '').trim();
                }
                addInfoRow("Версия МП", version);
                break;
            }
        }

        for (const [index, headerText] of Object.entries(headersData)) {
            const num = parseInt(index);
            if (headerText === "Оператор") {
                addInfoRow("Оператор", data[num] || 'Не найдено');
                break;
            }
        }

        let regionValue = 'Не найдено';
        for (const [index, headerText] of Object.entries(headersData)) {
            const num = parseInt(index);
            if (headerText === "Регион" || headerText === "Город" || /регион|область|край/i.test(headerText)) {
                regionValue = data[num] || 'Не найдено';
                addInfoRow("Регион", regionValue);
                if (regionValue !== 'Не найдено') {
                    const timezoneOffset = findTimezone(regionValue);
                    if (timezoneOffset !== null) {
                        const timezoneValue = timezoneOffset > 0 ? `+${timezoneOffset}` : timezoneOffset;
                        addInfoRow("Часовой пояс", `<span class="userinfo_timezone">${timezoneValue}</span> МСК`);
                    }
                }
                break;
            }
        }

        for (const [index, headerText] of Object.entries(headersData)) {
            const num = parseInt(index);
            if (headerText === "Крэши") {
                const crashValue = data[num] || 'Не найдено';
                addInfoRow("Crash", crashValue, crashValue !== '0');
                break;
            }
        }

        for (const [index, headerText] of Object.entries(headersData)) {
            const num = parseInt(index);
            if (headerText === "Root-статус") {
                const rootValue = data[num] || 'Не найдено';
                addInfoRow("Root", rootValue, rootValue !== 'Not Rooted');
                break;
            }
        }

        for (const [index, headerText] of Object.entries(headersData)) {
            const num = parseInt(index);
            if (headerText === "Сессии") {
                const sessionsValue = `${data[num] || 'Не найдено'} (${formatDate(data[num-1] || 'Не найдено')})`;
                addInfoRow("Сессии (последняя)", sessionsValue);
                break;
            }
        }

        for (const [index, headerText] of Object.entries(headersData)) {
            const num = parseInt(index);
            if (headerText === "appmetrica_device_id") {
                addInfoRow("Appmetrica ID", data[num] || 'Не найдено');
                break;
            }
        }

        return html || '<div style="color: rgb(150, 150, 150);">Данные не найдены</div>';
    }

    function findTimezone(regionName) {
        if (!regionName || regionName === 'Не найдено' || !TIMEZONES) return null;

        const normalized = regionName
            .toLowerCase()
            .replace(/[^а-яё\s-]/gi, '')
            .replace(/(область|край|республика|автономный округ|ао|город|г\.|район)\b/gi, '')
            .replace(/\s+/g, ' ')
            .trim();

        for (const [region, offset] of Object.entries(TIMEZONES)) {
            const normalizedRegion = region.toLowerCase();
            if (
                normalized === normalizedRegion ||
                normalized.includes(normalizedRegion) ||
                normalizedRegion.includes(normalized) ||
                regionName.toLowerCase().includes(normalizedRegion)
            ) {
                return offset;
            }
        }

        console.log('Часовой пояс не найден для:', regionName);
        return null;
    }

    function formatDate(dateString) {
        if (dateString === 'Не найдено') return dateString;
        const [year, month, day] = dateString.split('-');
        return `${day}.${month}.${year}`;
    }

    function fadeOut(element, callback) {
        element.style.opacity = '1';
        element.style.transition = 'opacity 0.7s ease, transform 0.7s ease';
        element.style.opacity = '0';
        element.style.transform = 'scale(0.9)';
        element.addEventListener('transitionend', () => callback(), { once: true });
    }

    // Запуск
    initializeUserInfo();
})();


background/updateId.js:
--------------------------------------------------
(function initIdUpdater() {
    console.log('[SFUA] Инициализация редактора ID');

    // Функция для инжекта стилей
    const injectStyles = (iframeDoc) => {
        return new Promise((resolve) => {
            const styleLink = iframeDoc.createElement('link');
            styleLink.rel = 'stylesheet';
            styleLink.href = chrome.runtime.getURL('background/styles/updateId.css');
            styleLink.onload = resolve;
            iframeDoc.head.appendChild(styleLink);
        });
    };

    // Создаём элемент для ввода ID
    const createIdInput = () => {
        const container = document.createElement('div');
        container.className = 'sfua-id-container';

        const input = document.createElement('input');
        input.type = 'text';
        input.className = 'sfua-id-input';
        input.placeholder = 'ID Appmetrica';

        const button = document.createElement('button');
        button.className = 'sfua-id-submit';
        button.disabled = true;
        button.innerHTML = `
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"/>
            </svg>
        `;

        container.appendChild(input);
        container.appendChild(button);
        return { container, input, button };
    };

    // Функция для обновления URL с новым ID
    const updateUrlWithNewId = (newId) => {
        const currentUrl = new URL(window.location.href);
        
        // Обновляем оба параметра
        currentUrl.searchParams.set('profileId', newId);
        currentUrl.searchParams.set('deviceId', newId);
        
        // Переходим по новому URL
        window.location.href = currentUrl.toString();
    };

    // Основная функция инициализации
    const init = async () => {
        const iframe = document.querySelector('iframe.iframe-integration__iframe');
        if (!iframe) {
            console.log('[SFUA] Iframe не найден, повтор через 1с');
            setTimeout(init, 1000);
            return;
        }

        try {
            const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
            
            // Инжектим стили
            await injectStyles(iframeDoc);
            
            const profileIdElement = iframeDoc.querySelector('.page-user-profile__profile-id');
            
            if (!profileIdElement) {
                console.log('[SFUA] Элемент ID не найден, повтор через 1с');
                setTimeout(init, 1000);
                return;
            }

            if (iframeDoc.querySelector('.sfua-id-container')) {
                return;
            }

            console.log('[SFUA] Найден элемент ID, добавляем поле ввода');
            
            const { container, input, button } = createIdInput();
            profileIdElement.parentNode.insertBefore(container, profileIdElement.nextSibling);

            // Получаем текущий ID из URL
            const getCurrentId = () => {
                const urlParams = new URLSearchParams(window.location.search);
                return urlParams.get('profileId') || '';
            };

            const currentId = getCurrentId();

            const checkId = () => {
                const newId = input.value.trim();

                if (!newId) {
                    button.disabled = true;
                    input.classList.remove('error', 'warning');
                    return;
                }

                if (newId === currentId) {
                    input.classList.add('warning');
                    input.classList.remove('error');
                    button.disabled = true;
                } else if (!/^\d{15,}$/.test(newId)) {
                    input.classList.add('error');
                    input.classList.remove('warning');
                    button.disabled = true;
                } else {
                    input.classList.remove('error', 'warning');
                    button.disabled = false;
                }
            };

            // Обработчик изменения input
            input.addEventListener('input', checkId);

            // Обработчик клика по кнопке
            button.addEventListener('click', () => {
                if (!button.disabled) {
                    updateUrlWithNewId(input.value.trim());
                }
            });

            // Обработчик нажатия Enter в input
            input.addEventListener('keypress', (e) => {
                if (e.key === 'Enter' && !button.disabled) {
                    updateUrlWithNewId(input.value.trim());
                }
            });

        } catch (error) {
            console.error('[SFUA] Ошибка инициализации:', error);
            setTimeout(init, 1000);
        }
    };

    // Запускаем с небольшой задержкой
    setTimeout(init, 100);
})();


background/styles/usertimezones.css:
--------------------------------------------------
.user_time {
    color: #999;
    font-size: 0.9em;
    margin-left: 3px;
    position: relative;
}

.user_time:hover::after {
    content: "Время сессии в часовом поясе пользователя";
    position: absolute;
    background: rgba(0, 0, 0, 0.8);
    color: #fff;
    padding: 5px 10px;
    border-radius: 4px;
    font-size: 12px;
    white-space: nowrap;
    z-index: 1000;
    bottom: 100%;
    left: 0;
}


background/styles/updateId.css:
--------------------------------------------------
.sfua-id-container {
    display: flex;
    gap: 8px;
    margin-top: 8px;
    width: 100%;
    margin-bottom: 10px;
    align-items: center;
}

.sfua-id-input {
    padding: 8px 12px;
    border: 1px solid #ddd;
    border-radius: 4px;
    font-size: 14px;
    width: 100%;
    transition: all 0.2s;
    outline: none;
}

.sfua-id-input.error {
    border: 1px solid #ff6b6b;
    transition: all 0.2s;
}

.sfua-id-input.warning {
    border: 1px solid #ffd700;
    transition: all 0.2s;
}

.sfua-id-submit {
    background: #1983ff;
    color: white;
    border: none;
    border-radius: 4px;
    padding: 8px;
    cursor: pointer;
    transition: all 0.2s;
    display: flex;
    align-items: center;
    justify-content: center;
    width: 32px;
    height: 32px;
}

.sfua-id-submit:hover:not(:disabled) {
    background: #1673e0;
}

.sfua-id-submit:disabled {
    background: #cccccc;
    cursor: not-allowed;
    opacity: 0.7;
}

.sfua-id-submit svg {
    width: 16px;
    height: 16px;
}


background/styles/userinfo.css:
--------------------------------------------------
/* background/styles/userinfo.css */

.userinfo_container {
    margin-top: 0;
    width: 100%;
    min-height: 100px;
    color: rgb(51, 51, 51);
    overflow: hidden;
    font-size: 11px;
    transform-origin: top;
    transition: transform 0.3s ease-out;
}

.userinfo_wrapper {
    display: flex;
    align-items: center;
    margin-bottom: 4px;
}

.userinfo_title {
    width: 120px;
    color: rgb(150, 150, 150);
    font-weight: bold;
}

.userinfo_data {
    color: inherit;
    flex: 1;
}

.popup {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background-color: rgba(0, 0, 0, 0.7);
    color: white;
    padding: 10px 20px;
    border-radius: 5px;
    opacity: 0;
    transition: opacity 0.3s ease;
    z-index: 10000;
}

.page-user-profile__profile-image {
    transition: transform 0.6s cubic-bezier(0.4, 0, 0.2, 1) !important;
}

.toggle-details-button {
    display: block;
    width: 100%;
    height: 30px;
    color: white;
    background-color: #4299e1;
    margin-bottom: 5px;
    font-size: 14px;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    overflow: hidden;
    position: relative;
    text-align: center;
    line-height: 30px;
    transform-origin: top center;
    transition: transform 0.3s ease-out, max-height 0.4s ease;
}

.toggle-details-button:hover {
    background-color: #266396;
}

.hidden {
    display: none !important;
}

.profile-info-table_js_inited {
    margin-top: 7px !important;
}

.profile-info-table__row-header {
    padding-bottom: 5px !important;
}

/* Анимация для таблицы */
table.profile-info-table__table {
    transform-origin: top;
    transition: transform 0.3s ease-out;
}


data/timezones.json:
--------------------------------------------------
{
      "Москва": 0,
      "Санкт-Петербург": 0,
      "Калининград": -1,
      "Самара": 1,
      "Самарская область": 1,
      "Екатеринбург": 2,
      "Омск": 3,
      "Красноярск": 4,
      "Иркутск": 5,
      "Якутск": 6,
      "Владивосток": 7,
      "Магадан": 8,
      "Камчатка": 9,
      "Воронеж": 0,
      "Воронежская область": 0,
      "Ростов-на-Дону": 0,
      "Ростовская область": 0,
      "Нижний Новгород": 0,
      "Нижегородская область": 0,
      "Казань": 0,
      "Республика Татарстан": 0,
      "Уфа": 2,
      "Республика Башкортостан": 2,
      "Новосибирск": 4,
      "Новосибирская область": 4,
      "Краснодар": 0,
      "Краснодарский край": 0,
      "Пермь": 2,
      "Пермский край": 2,
      "Волгоград": 0,
      "Волгоградская область": 0,
      "Саратов": 1,
      "Саратовская область": 1,
      "Тюмень": 2,
      "Тюменская область": 2,
      "Ижевск": 1,
      "Удмуртская Республика": 1,
      "Барнаул": 4,
      "Алтайский край": 4,
      "Улан-Удэ": 5,
      "Республика Бурятия": 5,
      "Чита": 6,
      "Забайкальский край": 6,
      "Петропавловск-Камчатский": 9,
      "Камчатский край": 9,
      "Хабаровск": 7,
      "Хабаровский край": 7,
      "Владимир": 0,
      "Владимирская область": 0,
      "Сочи": 0,
      "Тула": 0,
      "Тульская область": 0,
      "Киров": 0,
      "Кировская область": 0,
      "Челябинск": 2,
      "Челябинская область": 2,
      "Оренбург": 2,
      "Оренбургская область": 2,
      "Пенза": 0,
      "Пензенская область": 0,
      "Рязань": 0,
      "Рязанская область": 0,
      "Астрахань": 1,
      "Астраханская область": 1,
      "Набережные Челны": 0,
      "Томск": 4,
      "Томская область": 4,
      "Кемерово": 4,
      "Кемеровская область": 4,
      "Смоленск": 0,
      "Смоленская область": 0,
      "Курск": 0,
      "Курская область": 0,
      "Орел": 0,
      "Орловская область": 0,
      "Белгород": 0,
      "Белгородская область": 0,
      "Архангельск": 0,
      "Архангельская область": 0,
      "Мурманск": 0,
      "Мурманская область": 0,
      "Северодвинск": 0,
      "Йошкар-Ола": 0,
      "Республика Марий Эл": 0,
      "Сыктывкар": 0,
      "Республика Коми": 0,
      "Нальчик": 0,
      "Кабардино-Балкария": 0,
      "Ставрополь": 0,
      "Ставропольский край": 0,
      "Грозный": 0,
      "Чеченская Республика": 0,
      "Махачкала": 0,
      "Дагестан": 0,
      "Владикавказ": 0,
      "Северная Осетия": 0,
      "Ярославль": 0,
      "Ярославская область": 0,
      "Кострома": 0,
      "Костромская область": 0,
      "Иваново": 0,
      "Ивановская область": 0,
      "Брянск": 0,
      "Брянская область": 0,
      "Курган": 2,
      "Курганская область": 2,
      "Севастополь": 0,
      "Республика Крым": 0,
      "Симферополь": 0,
      "Сахалин": 7,
      "Сахалинская область" : 7,
      "Калуга" : 0,
      "Калужская область" : 0
    }


============================================================
СТРУКТУРА ПРОЕКТА:
============================================================
├── 📄 128.png
├── 📁 actions/
│   ├── 📄 clickeventelements.js
│   ├── 📄 clickpluselements.js
│   ├── 📄 found_error.js
│   ├── 📄 loadallevents.js
│   ├── 📄 loadallevents_error.js
│   ├── 📄 showmoresession.js
│   ├── 📄 showmoresession_error.js
│   └── 📄 updateprogress.js
├── 📄 allcode.py
├── 📁 background/
│   ├── 📁 styles/
│   │   ├── 📄 updateId.css
│   │   ├── 📄 userinfo.css
│   │   └── 📄 usertimezones.css
│   ├── 📄 updateId.js
│   └── 📄 userinfo.js
├── 📄 background.js
├── 📁 content/
│   ├── 📄 scrolltotop.js
│   ├── 📄 showcurrent.js
│   ├── 📁 styles/
│   │   └── 📄 showcurrent.css
│   ├── 📄 sync_manual_clicks.js
│   └── 📄 usertimezone.js
├── 📁 data/
│   └── 📄 timezones.json
├── 📄 how_to_use.css
├── 📄 how_to_use.html
├── 📄 how_to_use.js
├── 📁 icons/
│   ├── 📄 icon128.png
│   ├── 📄 icon16.png
│   └── 📄 icon48.png
├── 📄 manifest.json
├── 📄 modal_error.js
├── 📄 path.py
├── 📄 popup.html
├── 📄 popup.js
├── 📄 progress.css
├── 📄 progress.js
├── 📄 progress_error.css
├── 📄 progress_error.js
├── 📄 project_content.txt
└── 📄 styles.css
